{
  "module_id": 5,
  "title": "Special Methods (Magic Methods)",
  "order": 6,
  "reading_content": "\n<h3>Special Methods (Magic Methods/Dunder Methods)</h3>\n<p>Special methods (also called magic methods or dunder methods) allow your classes to implement built-in Python behaviors, making your objects feel natural and Pythonic.</p>\n\n<h4>String Representation: __str__ vs __repr__:</h4>\n<pre><code>class Book:\n    def __init__(self, title, author, year):\n        self.title = title\n        self.author = author\n        self.year = year\n    \n    def __str__(self):\n        \"\"\"User-friendly string representation.\"\"\"\n        return f\"{self.title} by {self.author}\"\n    \n    def __repr__(self):\n        \"\"\"Developer-friendly representation (for debugging).\"\"\"\n        return f\"Book('{self.title}', '{self.author}', {self.year})\"\n\nbook = Book(\"1984\", \"George Orwell\", 1949)\n\nprint(book)         # Uses __str__ → 1984 by George Orwell\nprint(repr(book))   # Uses __repr__ → Book('1984', 'George Orwell', 1949)\nprint(str(book))    # 1984 by George Orwell\n\n# In interactive Python:\n# >>> book\n# Book('1984', 'George Orwell', 1949)  # Uses __repr__\n</code></pre>\n\n<h4>Container Methods: __len__, __getitem__, __setitem__:</h4>\n<pre><code>class Library:\n    def __init__(self):\n        self.books = []\n    \n    def __len__(self):\n        \"\"\"Return number of books.\"\"\"\n        return len(self.books)\n    \n    def __getitem__(self, index):\n        \"\"\"Access books by index: library[0].\"\"\"\n        return self.books[index]\n    \n    def __setitem__(self, index, value):\n        \"\"\"Set book by index: library[0] = book.\"\"\"\n        self.books[index] = value\n    \n    def add_book(self, book):\n        self.books.append(book)\n\nlibrary = Library()\nlibrary.add_book(\"1984\")\nlibrary.add_book(\"Brave New World\")\nlibrary.add_book(\"Fahrenheit 451\")\n\nprint(len(library))     # Uses __len__ → 3\nprint(library[0])       # Uses __getitem__ → 1984\nlibrary[1] = \"Animal Farm\"  # Uses __setitem__\nprint(library[1])       # Animal Farm\n\n# Can iterate because of __getitem__\nfor book in library:\n    print(book)\n</code></pre>\n\n<h4>Comparison Methods:</h4>\n<pre><code>class Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n    \n    def __eq__(self, other):\n        \"\"\"Check equality: student1 == student2.\"\"\"\n        return self.grade == other.grade\n    \n    def __lt__(self, other):\n        \"\"\"Less than: student1 < student2.\"\"\"\n        return self.grade < other.grade\n    \n    def __le__(self, other):\n        \"\"\"Less than or equal: student1 <= student2.\"\"\"\n        return self.grade <= other.grade\n    \n    def __gt__(self, other):\n        \"\"\"Greater than: student1 > student2.\"\"\"\n        return self.grade > other.grade\n    \n    def __ge__(self, other):\n        \"\"\"Greater than or equal: student1 >= student2.\"\"\"\n        return self.grade >= other.grade\n    \n    def __str__(self):\n        return f\"{self.name} (Grade: {self.grade})\"\n\nalice = Student(\"Alice\", 85)\nbob = Student(\"Bob\", 92)\ncharlie = Student(\"Charlie\", 85)\n\nprint(alice == charlie)  # True (same grade)\nprint(alice < bob)       # True (85 < 92)\nprint(bob > alice)       # True (92 > 85)\n\n# Can now sort students!\nstudents = [bob, alice, charlie]\nstudents.sort()  # Sorts by grade using __lt__\nfor student in students:\n    print(student)\n# Output:\n# Alice (Grade: 85)\n# Charlie (Grade: 85)\n# Bob (Grade: 92)\n</code></pre>\n\n<h4>Arithmetic Operators:</h4>\n<pre><code>class Money:\n    def __init__(self, amount):\n        self.amount = amount\n    \n    def __add__(self, other):\n        \"\"\"Addition: money1 + money2.\"\"\"\n        return Money(self.amount + other.amount)\n    \n    def __sub__(self, other):\n        \"\"\"Subtraction: money1 - money2.\"\"\"\n        return Money(self.amount - other.amount)\n    \n    def __mul__(self, multiplier):\n        \"\"\"Multiplication: money * 2.\"\"\"\n        return Money(self.amount * multiplier)\n    \n    def __truediv__(self, divisor):\n        \"\"\"Division: money / 2.\"\"\"\n        return Money(self.amount / divisor)\n    \n    def __str__(self):\n        return f\"${self.amount:.2f}\"\n\nmoney1 = Money(100)\nmoney2 = Money(50)\n\nprint(money1 + money2)  # $150.00\nprint(money1 - money2)  # $50.00\nprint(money1 * 2)       # $200.00\nprint(money1 / 4)       # $25.00\n</code></pre>\n\n<h4>__call__: Make Objects Callable:</h4>\n<pre><code>class Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n    \n    def __call__(self, value):\n        \"\"\"Make object callable like a function.\"\"\"\n        return value * self.factor\n\n# Create a \"function\" that doubles numbers\ndouble = Multiplier(2)\ntriple = Multiplier(3)\n\nprint(double(5))  # 10 (calls __call__)\nprint(triple(5))  # 15\n\n# Another example: Validator\nclass Validator:\n    def __init__(self, min_value, max_value):\n        self.min_value = min_value\n        self.max_value = max_value\n    \n    def __call__(self, value):\n        return self.min_value <= value <= self.max_value\n\nage_validator = Validator(0, 120)\nprint(age_validator(25))   # True\nprint(age_validator(150))  # False\n</code></pre>\n\n<h4>__enter__ and __exit__: Context Managers:</h4>\n<pre><code>class FileHandler:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n        self.file = None\n    \n    def __enter__(self):\n        \"\"\"Called when entering 'with' block.\"\"\"\n        print(f\"Opening {self.filename}\")\n        self.file = open(self.filename, self.mode)\n        return self.file\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Called when exiting 'with' block (even if error occurs).\"\"\"\n        print(f\"Closing {self.filename}\")\n        if self.file:\n            self.file.close()\n        return False  # Don't suppress exceptions\n\n# Use with 'with' statement\nwith FileHandler('test.txt', 'w') as f:\n    f.write('Hello, World!')\n# File automatically closed after block\n\n# Another example: Timer\nimport time\n\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        return self\n    \n    def __exit__(self, *args):\n        self.end = time.time()\n        print(f\"Time elapsed: {self.end - self.start:.4f} seconds\")\n        return False\n\nwith Timer():\n    # Some time-consuming operation\n    total = sum(range(1000000))\n# Output: Time elapsed: 0.0234 seconds\n</code></pre>\n\n<h4>__bool__: Truth Value Testing:</h4>\n<pre><code>class BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n    \n    def __bool__(self):\n        \"\"\"Account is truthy if balance > 0.\"\"\"\n        return self.balance > 0\n\naccount1 = BankAccount(100)\naccount2 = BankAccount(0)\n\nif account1:\n    print(\"Account 1 has money\")  # Prints\n\nif not account2:\n    print(\"Account 2 is empty\")   # Prints\n</code></pre>\n\n<h4>__contains__: Membership Testing:</h4>\n<pre><code>class Team:\n    def __init__(self):\n        self.members = []\n    \n    def add_member(self, name):\n        self.members.append(name)\n    \n    def __contains__(self, name):\n        \"\"\"Check if member in team: 'Alice' in team.\"\"\"\n        return name in self.members\n\nteam = Team()\nteam.add_member(\"Alice\")\nteam.add_member(\"Bob\")\n\nprint(\"Alice\" in team)    # True\nprint(\"Charlie\" in team)  # False\n</code></pre>\n\n<h4>Complete Example - Vector Class:</h4>\n<pre><code>import math\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n    \n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n    \n    def __len__(self):\n        \"\"\"Return magnitude (length) of vector.\"\"\"\n        return int(math.sqrt(self.x ** 2 + self.y ** 2))\n    \n    def __abs__(self):\n        \"\"\"Return exact magnitude using abs(vector).\"\"\"\n        return math.sqrt(self.x ** 2 + self.y ** 2)\n    \n    def __bool__(self):\n        \"\"\"Vector is truthy if not zero vector.\"\"\"\n        return bool(abs(self))\n\nv1 = Vector(3, 4)\nv2 = Vector(1, 2)\n\nprint(v1)                    # Vector(3, 4)\nprint(v1 + v2)               # Vector(4, 6)\nprint(v1 - v2)               # Vector(2, 2)\nprint(v1 * 2)                # Vector(6, 8)\nprint(len(v1))               # 5 (approximate)\nprint(abs(v1))               # 5.0 (exact)\nprint(v1 == Vector(3, 4))    # True\nprint(bool(Vector(0, 0)))    # False (zero vector)\nprint(bool(v1))              # True\n</code></pre>\n\n<h4>Common Special Methods Table:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Category</th>\n        <th>Methods</th>\n        <th>Purpose</th>\n    </tr>\n    <tr>\n        <td><strong>String Representation</strong></td>\n        <td>__str__, __repr__</td>\n        <td>Convert object to string</td>\n    </tr>\n    <tr>\n        <td><strong>Arithmetic</strong></td>\n        <td>__add__, __sub__, __mul__, __truediv__</td>\n        <td>+, -, *, / operators</td>\n    </tr>\n    <tr>\n        <td><strong>Comparison</strong></td>\n        <td>__eq__, __lt__, __le__, __gt__, __ge__</td>\n        <td>==, <, <=, >, >= operators</td>\n    </tr>\n    <tr>\n        <td><strong>Container</strong></td>\n        <td>__len__, __getitem__, __setitem__, __contains__</td>\n        <td>len(), indexing, membership</td>\n    </tr>\n    <tr>\n        <td><strong>Context Manager</strong></td>\n        <td>__enter__, __exit__</td>\n        <td>with statement</td>\n    </tr>\n    <tr>\n        <td><strong>Callable</strong></td>\n        <td>__call__</td>\n        <td>Make object callable like function</td>\n    </tr>\n    <tr>\n        <td><strong>Type Conversion</strong></td>\n        <td>__int__, __float__, __bool__</td>\n        <td>int(), float(), bool()</td>\n    </tr>\n</table>\n\n<h4>Best Practices:</h4>\n<pre><code># 1. Always implement both __str__ and __repr__\nclass Person:\n    def __str__(self):   # For users\n        return self.name\n    def __repr__(self):  # For developers\n        return f\"Person('{self.name}', {self.age})\"\n\n# 2. If you implement __eq__, also implement __hash__ for sets/dicts\nclass Point:\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n    \n    def __hash__(self):\n        return hash((self.x, self.y))\n\n# 3. Comparison methods should be consistent\n# If a < b, then b > a should also be true\n\n# 4. Use @functools.total_ordering to generate missing comparison methods\nfrom functools import total_ordering\n\n@total_ordering\nclass Student:\n    def __eq__(self, other):\n        return self.grade == other.grade\n    \n    def __lt__(self, other):\n        return self.grade < other.grade\n    # __le__, __gt__, __ge__ automatically generated!\n</code></pre>\n        ",
  "starter_code": "# TODO: Create a Temperature class with special methods:\n# 1. __init__(celsius) - Initialize with Celsius temperature\n# 2. __str__() - Return formatted string like \"25.0°C\"\n# 3. __repr__() - Return \"Temperature(25.0)\"\n# 4. __add__(other) - Add two temperatures (result in Celsius)\n# 5. __eq__(other) - Check if two temperatures are equal\n# 6. __lt__(other) - Check if this temperature is less than another\n#\n# Test:\n# t1 = Temperature(25.0)\n# t2 = Temperature(30.0)\n# print(t1)              # 25.0°C\n# print(repr(t1))       # Temperature(25.0)\n# print(t1 + t2)        # 55.0°C\n# print(t1 == t2)       # False\n# print(t1 < t2)        # True\n\n",
  "solution_code": "class Temperature:\n    def __init__(self, celsius):\n        self.celsius = celsius\n    \n    def __str__(self):\n        return f\"{self.celsius}°C\"\n    \n    def __repr__(self):\n        return f\"Temperature({self.celsius})\"\n    \n    def __add__(self, other):\n        return Temperature(self.celsius + other.celsius)\n    \n    def __eq__(self, other):\n        return self.celsius == other.celsius\n    \n    def __lt__(self, other):\n        return self.celsius < other.celsius\n\nt1 = Temperature(25.0)\nt2 = Temperature(30.0)\nprint(t1)              # 25.0°C\nprint(repr(t1))       # Temperature(25.0)\nprint(t1 + t2)        # 55.0°C\nprint(t1 == t2)       # False\nprint(t1 < t2)        # True",
  "learning_objectives": [
    "Implement string representation methods (__str__, __repr__)",
    "Create arithmetic operators for custom classes",
    "Implement comparison methods for sorting and equality",
    "Use __call__ to make objects callable",
    "Create context managers with __enter__ and __exit__"
  ],
  "key_concepts": [
    "Special Methods (Magic/Dunder Methods)",
    "__str__ vs __repr__",
    "Operator Overloading",
    "__len__, __getitem__, __setitem__",
    "Comparison Methods (__eq__, __lt__, __gt__)",
    "__call__ (Callable Objects)",
    "__enter__, __exit__ (Context Managers)",
    "@functools.total_ordering"
  ],
  "test_cases": [
    {
      "name": "Test: Temperature operations",
      "input": "",
      "expected_output": "25.0°C\nTemperature(25.0)\n55.0°C\nFalse\nTrue"
    }
  ],
  "hints": [
    "__str__ returns user-friendly string: return f\\\"{self.celsius}°C\\\"",
    "__repr__ returns developer-friendly string: return f\\\"Temperature({self.celsius})\\\"",
    "__add__ creates new Temperature: return Temperature(self.celsius + other.celsius)",
    "__eq__ compares values: return self.celsius == other.celsius",
    "__lt__ for less than comparison: return self.celsius < other.celsius"
  ],
  "visual_content": {
    "diagram": {
      "type": "special_methods_overview",
      "title": "Common Special Methods",
      "categories": [
        {
          "name": "String Representation",
          "methods": ["__str__", "__repr__"],
          "usage": "print(obj), str(obj), repr(obj)"
        },
        {
          "name": "Arithmetic",
          "methods": ["__add__", "__sub__", "__mul__", "__truediv__"],
          "usage": "obj1 + obj2, obj1 - obj2, obj1 * 2, obj1 / 2"
        },
        {
          "name": "Comparison",
          "methods": ["__eq__", "__lt__", "__le__", "__gt__", "__ge__"],
          "usage": "obj1 == obj2, obj1 < obj2, sorted(objects)"
        },
        {
          "name": "Container",
          "methods": ["__len__", "__getitem__", "__setitem__"],
          "usage": "len(obj), obj[0], obj[0] = value"
        }
      ],
      "example": {
        "code": "class Vector:\\n    def __add__(self, other):\\n        return Vector(self.x + other.x, self.y + other.y)\\n\\nv1 + v2  # Calls __add__"
      }
    }
  }
}