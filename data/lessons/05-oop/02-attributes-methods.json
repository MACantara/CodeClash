{
  "module_id": 5,
  "title": "Attributes & Methods - Instance, Class & Static",
  "order": 2,
  "reading_content": "\n<h3>Types of Attributes and Methods</h3>\n<p>Python classes support three types of methods and two types of attributes, each serving different purposes.</p>\n\n<h4>Instance Attributes:</h4>\n<pre><code># Instance attributes are unique to each object\nclass Person:\n    def __init__(self, name, age):\n        self.name = name  # Instance attribute\n        self.age = age    # Instance attribute\n\nalice = Person(\"Alice\", 25)\nbob = Person(\"Bob\", 30)\n\nprint(alice.name)  # Alice\nprint(bob.name)    # Bob\n\n# Modify instance attribute\nalice.age = 26\nprint(alice.age)  # 26\nprint(bob.age)    # 30 (unchanged)\n\n# Add new instance attribute dynamically\nalice.email = \"alice@example.com\"\nprint(alice.email)  # alice@example.com\n# print(bob.email)  # ❌ AttributeError (bob doesn't have email)\n</code></pre>\n\n<h4>Class Attributes:</h4>\n<pre><code># Class attributes are shared by ALL instances\nclass Dog:\n    species = \"Canis familiaris\"  # Class attribute\n    \n    def __init__(self, name, breed):\n        self.name = name    # Instance attribute\n        self.breed = breed  # Instance attribute\n\ndog1 = Dog(\"Buddy\", \"Golden Retriever\")\ndog2 = Dog(\"Max\", \"Beagle\")\n\n# Both share the same class attribute\nprint(dog1.species)  # Canis familiaris\nprint(dog2.species)  # Canis familiaris\n\n# Change class attribute affects ALL instances\nDog.species = \"Canis lupus familiaris\"\nprint(dog1.species)  # Canis lupus familiaris\nprint(dog2.species)  # Canis lupus familiaris\n\n# Instance attributes are separate\nprint(dog1.name)  # Buddy\nprint(dog2.name)  # Max\n</code></pre>\n\n<h4>When to Use Class vs Instance Attributes:</h4>\n<pre><code># Use CLASS attributes for data shared by all instances\nclass Circle:\n    pi = 3.14159  # Same for all circles\n    \n    def __init__(self, radius):\n        self.radius = radius  # Unique to each circle\n    \n    def area(self):\n        return Circle.pi * self.radius ** 2\n\n# Use CLASS attributes for counting instances\nclass Employee:\n    employee_count = 0  # Shared counter\n    \n    def __init__(self, name):\n        self.name = name  # Instance-specific\n        Employee.employee_count += 1  # Increment shared counter\n    \n    @classmethod\n    def get_count(cls):\n        return cls.employee_count\n\nemp1 = Employee(\"Alice\")\nemp2 = Employee(\"Bob\")\nemp3 = Employee(\"Charlie\")\n\nprint(Employee.get_count())  # 3\n</code></pre>\n\n<h4>Instance Methods:</h4>\n<pre><code># Instance methods operate on instance data\nclass BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self.balance = balance\n    \n    def deposit(self, amount):  # Instance method\n        \"\"\"Takes 'self' as first parameter.\"\"\"\n        self.balance += amount\n        return self.balance\n    \n    def withdraw(self, amount):  # Instance method\n        if amount <= self.balance:\n            self.balance -= amount\n            return self.balance\n        return \"Insufficient funds\"\n\naccount = BankAccount(\"Alice\", 1000)\nprint(account.deposit(500))   # 1500\nprint(account.withdraw(200))  # 1300\n</code></pre>\n\n<h4>Class Methods:</h4>\n<pre><code># Class methods work with class attributes, not instance attributes\nclass Date:\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n    \n    @classmethod\n    def from_string(cls, date_string):\n        \"\"\"Alternative constructor - takes 'cls' as first parameter.\"\"\"\n        year, month, day = map(int, date_string.split('-'))\n        return cls(year, month, day)  # Create instance using cls\n    \n    @classmethod\n    def is_leap_year(cls, year):\n        \"\"\"Utility method that doesn't need instance data.\"\"\"\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    def __str__(self):\n        return f\"{self.year}-{self.month:02d}-{self.day:02d}\"\n\n# Regular constructor\ndate1 = Date(2024, 1, 15)\nprint(date1)  # 2024-01-15\n\n# Class method as alternative constructor\ndate2 = Date.from_string(\"2024-03-20\")\nprint(date2)  # 2024-03-20\n\n# Class method for utility\nprint(Date.is_leap_year(2024))  # True\nprint(Date.is_leap_year(2023))  # False\n</code></pre>\n\n<h4>Static Methods:</h4>\n<pre><code># Static methods don't access instance or class data\nclass MathUtils:\n    @staticmethod\n    def add(a, b):\n        \"\"\"No 'self' or 'cls' parameter - just a regular function.\"\"\"\n        return a + b\n    \n    @staticmethod\n    def is_even(n):\n        return n % 2 == 0\n    \n    @staticmethod\n    def celsius_to_fahrenheit(celsius):\n        return (celsius * 9/5) + 32\n\n# Call without creating instance\nprint(MathUtils.add(5, 3))  # 8\nprint(MathUtils.is_even(4))  # True\nprint(MathUtils.celsius_to_fahrenheit(25))  # 77.0\n\n# Can also call from instance (but unusual)\nmath = MathUtils()\nprint(math.add(10, 20))  # 30\n</code></pre>\n\n<h4>Comparison of Method Types:</h4>\n<pre><code>class Pizza:\n    # Class attribute\n    base_price = 10.0\n    \n    def __init__(self, size, toppings):\n        # Instance attributes\n        self.size = size\n        self.toppings = toppings\n    \n    # Instance method - uses 'self', accesses instance data\n    def calculate_price(self):\n        price = Pizza.base_price\n        if self.size == \"large\":\n            price += 5\n        price += len(self.toppings) * 1.5\n        return price\n    \n    # Class method - uses 'cls', works with class data\n    @classmethod\n    def update_base_price(cls, new_price):\n        cls.base_price = new_price\n    \n    # Static method - no 'self' or 'cls', independent utility\n    @staticmethod\n    def is_valid_size(size):\n        return size in [\"small\", \"medium\", \"large\"]\n\n# Instance method usage\npizza1 = Pizza(\"large\", [\"pepperoni\", \"mushrooms\"])\nprint(pizza1.calculate_price())  # 18.0\n\n# Class method usage\nPizza.update_base_price(12.0)\npizza2 = Pizza(\"small\", [\"cheese\"])\nprint(pizza2.calculate_price())  # 13.5 (uses new base price)\n\n# Static method usage\nprint(Pizza.is_valid_size(\"large\"))    # True\nprint(Pizza.is_valid_size(\"gigantic\")) # False\n</code></pre>\n\n<h4>Property Decorators:</h4>\n<pre><code># @property makes methods act like attributes\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius  # \"Private\" attribute\n    \n    @property\n    def celsius(self):\n        \"\"\"Getter for celsius.\"\"\"\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        \"\"\"Setter for celsius with validation.\"\"\"\n        if value < -273.15:\n            raise ValueError(\"Temperature below absolute zero!\")\n        self._celsius = value\n    \n    @property\n    def fahrenheit(self):\n        \"\"\"Computed property (no setter).\"\"\"\n        return (self._celsius * 9/5) + 32\n\ntemp = Temperature(25)\nprint(temp.celsius)     # 25 (calls getter)\nprint(temp.fahrenheit)  # 77.0 (computed)\n\ntemp.celsius = 30       # Calls setter\nprint(temp.celsius)     # 30\nprint(temp.fahrenheit)  # 86.0 (automatically updated)\n\n# temp.celsius = -300  # ❌ ValueError: Temperature below absolute zero!\n</code></pre>\n\n<h4>Practical Example - User Class:</h4>\n<pre><code>class User:\n    # Class attribute\n    total_users = 0\n    \n    def __init__(self, username, email):\n        # Instance attributes\n        self.username = username\n        self.email = email\n        self.is_active = True\n        User.total_users += 1\n    \n    # Instance method\n    def deactivate(self):\n        \"\"\"Deactivate user account.\"\"\"\n        self.is_active = False\n        return f\"{self.username} deactivated\"\n    \n    def activate(self):\n        \"\"\"Activate user account.\"\"\"\n        self.is_active = True\n        return f\"{self.username} activated\"\n    \n    # Class method\n    @classmethod\n    def get_user_count(cls):\n        \"\"\"Get total number of users.\"\"\"\n        return cls.total_users\n    \n    @classmethod\n    def create_guest(cls):\n        \"\"\"Factory method to create guest user.\"\"\"\n        import random\n        guest_id = random.randint(1000, 9999)\n        return cls(f\"guest_{guest_id}\", f\"guest{guest_id}@example.com\")\n    \n    # Static method\n    @staticmethod\n    def is_valid_email(email):\n        \"\"\"Check if email format is valid.\"\"\"\n        return '@' in email and '.' in email\n    \n    def __str__(self):\n        status = \"active\" if self.is_active else \"inactive\"\n        return f\"User({self.username}, {status})\"\n\n# Create users\nuser1 = User(\"alice\", \"alice@example.com\")\nuser2 = User(\"bob\", \"bob@example.com\")\n\n# Instance methods\nprint(user1.deactivate())  # alice deactivated\n\n# Class methods\nprint(User.get_user_count())  # 2\nguest = User.create_guest()\nprint(guest)  # User(guest_1234, active)\nprint(User.get_user_count())  # 3\n\n# Static methods\nprint(User.is_valid_email(\"test@example.com\"))  # True\nprint(User.is_valid_email(\"invalid\"))  # False\n</code></pre>\n\n<h4>Quick Reference Table:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Type</th>\n        <th>First Parameter</th>\n        <th>Decorator</th>\n        <th>Access To</th>\n        <th>Use Case</th>\n    </tr>\n    <tr>\n        <td><strong>Instance Method</strong></td>\n        <td>self</td>\n        <td>None</td>\n        <td>Instance attributes</td>\n        <td>Operate on instance data</td>\n    </tr>\n    <tr>\n        <td><strong>Class Method</strong></td>\n        <td>cls</td>\n        <td>@classmethod</td>\n        <td>Class attributes</td>\n        <td>Alternative constructors, class-level operations</td>\n    </tr>\n    <tr>\n        <td><strong>Static Method</strong></td>\n        <td>None</td>\n        <td>@staticmethod</td>\n        <td>Nothing (independent)</td>\n        <td>Utility functions related to class</td>\n    </tr>\n</table>\n        ",
  "starter_code": "# TODO: Create a 'Product' class with:\n# 1. Class attribute 'discount_rate' = 0.1 (10%)\n# 2. __init__(name, price) with instance attributes\n# 3. Instance method 'get_discounted_price()' that returns price after discount\n# 4. Class method 'set_discount_rate(rate)' to change class discount\n# 5. Static method 'is_valid_price(price)' that checks if price > 0\n#\n# Test:\n# product = Product(\"Laptop\", 1000)\n# print(product.get_discounted_price())  # 900.0\n# Product.set_discount_rate(0.2)\n# print(product.get_discounted_price())  # 800.0\n# print(Product.is_valid_price(100))     # True\n# print(Product.is_valid_price(-50))     # False\n\n",
  "solution_code": "class Product:\n    discount_rate = 0.1  # Class attribute\n    \n    def __init__(self, name, price):\n        self.name = name\n        self.price = price\n    \n    def get_discounted_price(self):\n        \"\"\"Instance method.\"\"\"\n        return self.price * (1 - Product.discount_rate)\n    \n    @classmethod\n    def set_discount_rate(cls, rate):\n        \"\"\"Class method.\"\"\"\n        cls.discount_rate = rate\n    \n    @staticmethod\n    def is_valid_price(price):\n        \"\"\"Static method.\"\"\"\n        return price > 0\n\nproduct = Product(\"Laptop\", 1000)\nprint(product.get_discounted_price())\nProduct.set_discount_rate(0.2)\nprint(product.get_discounted_price())\nprint(Product.is_valid_price(100))\nprint(Product.is_valid_price(-50))",
  "learning_objectives": [
    "Differentiate between instance, class, and static attributes",
    "Implement instance, class, and static methods appropriately",
    "Use @classmethod and @staticmethod decorators correctly",
    "Apply @property decorator to create computed attributes"
  ],
  "key_concepts": [
    "Instance Attributes",
    "Class Attributes",
    "Instance Methods",
    "Class Methods (@classmethod)",
    "Static Methods (@staticmethod)",
    "Property Decorator (@property)",
    "self vs cls"
  ],
  "test_cases": [
    {
      "name": "Test: Product class with all method types",
      "input": "",
      "expected_output": "900.0\n800.0\nTrue\nFalse"
    }
  ],
  "hints": [
    "Class attribute outside __init__: discount_rate = 0.1",
    "Instance method uses 'self': def get_discounted_price(self)",
    "Class method uses @classmethod and 'cls': @classmethod def set_discount_rate(cls, rate)",
    "Static method uses @staticmethod, no self/cls: @staticmethod def is_valid_price(price)",
    "Calculate discount: price * (1 - discount_rate)"
  ],
  "visual_content": {
    "comparison_diagram": {
      "type": "method_types_comparison",
      "methods": [
        {
          "type": "Instance Method",
          "syntax": "def method(self):",
          "first_param": "self (instance)",
          "decorator": "None",
          "example": "def deposit(self, amount):\\n    self.balance += amount",
          "use_case": "Operate on instance data"
        },
        {
          "type": "Class Method",
          "syntax": "@classmethod\\ndef method(cls):",
          "first_param": "cls (class)",
          "decorator": "@classmethod",
          "example": "@classmethod\\ndef from_string(cls, data):\\n    return cls(...)",
          "use_case": "Alternative constructors, modify class attributes"
        },
        {
          "type": "Static Method",
          "syntax": "@staticmethod\\ndef method():",
          "first_param": "None",
          "decorator": "@staticmethod",
          "example": "@staticmethod\\ndef is_valid(value):\\n    return value > 0",
          "use_case": "Utility functions related to class"
        }
      ]
    }
  }
}