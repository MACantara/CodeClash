{
  "module_id": 5,
  "title": "Inheritance - Parent & Child Classes",
  "order": 4,
  "reading_content": "\n<h3>Inheritance in Python</h3>\n<p>Inheritance allows a class (child) to inherit attributes and methods from another class (parent), promoting code reuse.</p>\n\n<h4>Basic Inheritance:</h4>\n<pre><code># Parent class (base class, superclass)\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        return f\"{self.name} makes a sound\"\n\n# Child class (derived class, subclass)\nclass Dog(Animal):  # Inherits from Animal\n    pass\n\n# Dog inherits everything from Animal\ndog = Dog(\"Buddy\")\nprint(dog.name)    # Buddy (inherited attribute)\nprint(dog.speak()) # Buddy makes a sound (inherited method)\n</code></pre>\n\n<h4>Extending Parent Class:</h4>\n<pre><code>class Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        return f\"{self.name} makes a sound\"\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)  # Call parent's __init__\n        self.breed = breed      # Add new attribute\n    \n    def wag_tail(self):  # Add new method\n        return f\"{self.name} wags tail\"\n\ndog = Dog(\"Buddy\", \"Golden Retriever\")\nprint(dog.name)       # Buddy (from parent)\nprint(dog.breed)      # Golden Retriever (from child)\nprint(dog.speak())    # Buddy makes a sound (from parent)\nprint(dog.wag_tail()) # Buddy wags tail (from child)\n</code></pre>\n\n<h4>Method Overriding:</h4>\n<pre><code># Child class can override parent methods\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        return f\"{self.name} makes a sound\"\n\nclass Dog(Animal):\n    def speak(self):  # Override parent method\n        return f\"{self.name} says Woof!\"\n\nclass Cat(Animal):\n    def speak(self):  # Override parent method\n        return f\"{self.name} says Meow!\"\n\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\n\nprint(dog.speak())  # Buddy says Woof! (overridden)\nprint(cat.speak())  # Whiskers says Meow! (overridden)\n</code></pre>\n\n<h4>Using super():</h4>\n<pre><code># super() calls parent class methods\nclass Vehicle:\n    def __init__(self, brand, year):\n        self.brand = brand\n        self.year = year\n    \n    def info(self):\n        return f\"{self.year} {self.brand}\"\n\nclass Car(Vehicle):\n    def __init__(self, brand, year, doors):\n        super().__init__(brand, year)  # Call parent constructor\n        self.doors = doors\n    \n    def info(self):  # Override but extend parent method\n        parent_info = super().info()  # Call parent's info()\n        return f\"{parent_info}, {self.doors} doors\"\n\ncar = Car(\"Toyota\", 2024, 4)\nprint(car.info())  # 2024 Toyota, 4 doors\n</code></pre>\n\n<h4>Multiple Inheritance:</h4>\n<pre><code># A class can inherit from multiple parents\nclass Flyer:\n    def fly(self):\n        return \"Flying through the air\"\n\nclass Swimmer:\n    def swim(self):\n        return \"Swimming in water\"\n\nclass Duck(Flyer, Swimmer):  # Inherits from both\n    def __init__(self, name):\n        self.name = name\n    \n    def quack(self):\n        return f\"{self.name} says Quack!\"\n\nduck = Duck(\"Donald\")\nprint(duck.quack())  # Donald says Quack!\nprint(duck.fly())    # Flying through the air (from Flyer)\nprint(duck.swim())   # Swimming in water (from Swimmer)\n</code></pre>\n\n<h4>Method Resolution Order (MRO):</h4>\n<pre><code># Python uses C3 linearization for MRO\nclass A:\n    def method(self):\n        return \"A's method\"\n\nclass B(A):\n    def method(self):\n        return \"B's method\"\n\nclass C(A):\n    def method(self):\n        return \"C's method\"\n\nclass D(B, C):  # Multiple inheritance\n    pass\n\nd = D()\nprint(d.method())  # B's method (B comes before C in inheritance list)\n\n# Check MRO\nprint(D.__mro__)\n# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)\n# D → B → C → A → object\n</code></pre>\n\n<h4>isinstance() and issubclass():</h4>\n<pre><code>class Animal:\n    pass\n\nclass Dog(Animal):\n    pass\n\nclass Cat(Animal):\n    pass\n\ndog = Dog()\ncat = Cat()\n\n# isinstance() checks if object is instance of class\nprint(isinstance(dog, Dog))     # True\nprint(isinstance(dog, Animal))  # True (Dog inherits from Animal)\nprint(isinstance(dog, Cat))     # False\nprint(isinstance(dog, object))  # True (everything inherits from object)\n\n# issubclass() checks if class is subclass of another\nprint(issubclass(Dog, Animal))    # True\nprint(issubclass(Animal, Dog))    # False\nprint(issubclass(Dog, object))    # True\nprint(issubclass(Dog, Dog))       # True\n</code></pre>\n\n<h4>Practical Example - Employee Hierarchy:</h4>\n<pre><code>class Employee:\n    \"\"\"Base class for all employees.\"\"\"\n    \n    def __init__(self, name, emp_id, salary):\n        self.name = name\n        self.emp_id = emp_id\n        self.salary = salary\n    \n    def get_details(self):\n        return f\"{self.name} (ID: {self.emp_id})\"\n    \n    def get_annual_salary(self):\n        return self.salary * 12\n    \n    def __str__(self):\n        return f\"Employee({self.name}, ${self.salary}/month)\"\n\nclass Manager(Employee):\n    \"\"\"Manager with team size and bonus.\"\"\"\n    \n    def __init__(self, name, emp_id, salary, team_size):\n        super().__init__(name, emp_id, salary)\n        self.team_size = team_size\n    \n    def get_details(self):  # Override\n        base = super().get_details()\n        return f\"{base}, Team Size: {self.team_size}\"\n    \n    def get_annual_salary(self):  # Override with bonus\n        base_salary = super().get_annual_salary()\n        bonus = base_salary * 0.20  # 20% bonus\n        return base_salary + bonus\n    \n    def __str__(self):\n        return f\"Manager({self.name}, Team: {self.team_size})\"\n\nclass Developer(Employee):\n    \"\"\"Developer with programming languages.\"\"\"\n    \n    def __init__(self, name, emp_id, salary, languages):\n        super().__init__(name, emp_id, salary)\n        self.languages = languages  # List of languages\n    \n    def get_details(self):  # Override\n        base = super().get_details()\n        langs = \", \".join(self.languages)\n        return f\"{base}, Languages: {langs}\"\n    \n    def __str__(self):\n        return f\"Developer({self.name}, {len(self.languages)} languages)\"\n\n# Usage\nemp = Employee(\"Alice\", \"E001\", 5000)\nmanager = Manager(\"Bob\", \"M001\", 8000, 10)\ndev = Developer(\"Charlie\", \"D001\", 7000, [\"Python\", \"Java\", \"C++\"])\n\nprint(emp.get_details())  # Alice (ID: E001)\nprint(manager.get_details())  # Bob (ID: M001), Team Size: 10\nprint(dev.get_details())  # Charlie (ID: D001), Languages: Python, Java, C++\n\nprint(f\"Annual: ${emp.get_annual_salary()}\")  # Annual: $60000\nprint(f\"Annual: ${manager.get_annual_salary()}\")  # Annual: $115200 (with bonus)\nprint(f\"Annual: ${dev.get_annual_salary()}\")  # Annual: $84000\n\n# Type checking\nprint(isinstance(manager, Manager))   # True\nprint(isinstance(manager, Employee))  # True\nprint(isinstance(dev, Manager))       # False\n</code></pre>\n\n<h4>Abstract Base Classes (ABC):</h4>\n<pre><code>from abc import ABC, abstractmethod\n\n# Abstract class - cannot be instantiated\nclass Shape(ABC):\n    def __init__(self, color):\n        self.color = color\n    \n    @abstractmethod\n    def area(self):\n        \"\"\"Must be implemented by child classes.\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        \"\"\"Must be implemented by child classes.\"\"\"\n        pass\n\n# Concrete class\nclass Rectangle(Shape):\n    def __init__(self, color, width, height):\n        super().__init__(color)\n        self.width = width\n        self.height = height\n    \n    def area(self):  # Implement abstract method\n        return self.width * self.height\n    \n    def perimeter(self):  # Implement abstract method\n        return 2 * (self.width + self.height)\n\nclass Circle(Shape):\n    def __init__(self, color, radius):\n        super().__init__(color)\n        self.radius = radius\n    \n    def area(self):  # Implement abstract method\n        return 3.14159 * self.radius ** 2\n    \n    def perimeter(self):  # Implement abstract method\n        return 2 * 3.14159 * self.radius\n\n# Cannot instantiate abstract class\n# shape = Shape(\"red\")  # ❌ TypeError\n\n# Can instantiate concrete classes\nrect = Rectangle(\"blue\", 5, 3)\ncircle = Circle(\"red\", 7)\n\nprint(rect.area())      # 15\nprint(circle.area())    # 153.93791\nprint(rect.perimeter()) # 16\n</code></pre>\n\n<h4>Inheritance vs Composition:</h4>\n<pre><code># Inheritance: \"IS-A\" relationship\nclass Dog(Animal):  # Dog IS-A Animal\n    pass\n\n# Composition: \"HAS-A\" relationship\nclass Engine:\n    def start(self):\n        return \"Engine started\"\n\nclass Car:  # Car HAS-A Engine\n    def __init__(self):\n        self.engine = Engine()  # Composition\n    \n    def start(self):\n        return self.engine.start()\n\ncar = Car()\nprint(car.start())  # Engine started\n\n# When to use:\n# - Inheritance: Shared behavior, \"is-a\" relationship\n# - Composition: Flexibility, \"has-a\" relationship, avoid deep hierarchies\n</code></pre>\n\n<h4>Benefits and Pitfalls:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Benefits</th>\n        <th>Pitfalls</th>\n    </tr>\n    <tr>\n        <td>Code reuse (DRY principle)</td>\n        <td>Deep hierarchies hard to understand</td>\n    </tr>\n    <tr>\n        <td>Polymorphism (treat different types uniformly)</td>\n        <td>Tight coupling between parent and child</td>\n    </tr>\n    <tr>\n        <td>Organize related classes</td>\n        <td>Changes to parent affect all children</td>\n    </tr>\n    <tr>\n        <td>Extend functionality without modifying parent</td>\n        <td>Multiple inheritance can be confusing</td>\n    </tr>\n</table>\n        ",
  "starter_code": "# TODO: Create an inheritance hierarchy:\n# 1. Base class 'Shape' with __init__(color) and method display()\n# 2. Child class 'Circle' that inherits from Shape\n#    - Add __init__(color, radius) using super()\n#    - Add method area() that returns pi * radius^2\n#    - Override display() to show \"Circle: [color], Area: [area]\"\n# 3. Child class 'Square' that inherits from Shape\n#    - Add __init__(color, side) using super()\n#    - Add method area() that returns side^2\n#    - Override display() to show \"Square: [color], Area: [area]\"\n#\n# Test:\n# circle = Circle(\"red\", 5)\n# square = Square(\"blue\", 4)\n# print(circle.display())  # Circle: red, Area: 78.53975\n# print(square.display())  # Square: blue, Area: 16\n\n",
  "solution_code": "class Shape:\n    def __init__(self, color):\n        self.color = color\n    \n    def display(self):\n        return f\"Shape: {self.color}\"\n\nclass Circle(Shape):\n    def __init__(self, color, radius):\n        super().__init__(color)\n        self.radius = radius\n    \n    def area(self):\n        return 3.14159 * self.radius ** 2\n    \n    def display(self):\n        return f\"Circle: {self.color}, Area: {self.area()}\"\n\nclass Square(Shape):\n    def __init__(self, color, side):\n        super().__init__(color)\n        self.side = side\n    \n    def area(self):\n        return self.side ** 2\n    \n    def display(self):\n        return f\"Square: {self.color}, Area: {self.area()}\"\n\ncircle = Circle(\"red\", 5)\nsquare = Square(\"blue\", 4)\nprint(circle.display())\nprint(square.display())",
  "learning_objectives": [
    "Create child classes that inherit from parent classes",
    "Use super() to call parent class methods",
    "Override parent methods in child classes",
    "Apply isinstance() and issubclass() for type checking"
  ],
  "key_concepts": [
    "Inheritance",
    "Parent Class (Base/Super)",
    "Child Class (Derived/Sub)",
    "super() Function",
    "Method Overriding",
    "Multiple Inheritance",
    "MRO (Method Resolution Order)",
    "Abstract Base Classes"
  ],
  "test_cases": [
    {
      "name": "Test: Shape inheritance",
      "input": "",
      "expected_output": "Circle: red, Area: 78.53975\nSquare: blue, Area: 16"
    }
  ],
  "hints": [
    "Parent class: class Shape: def __init__(self, color): self.color = color",
    "Child class: class Circle(Shape):",
    "Call parent constructor: super().__init__(color)",
    "Override display: def display(self): return f\"Circle: {self.color}, Area: {self.area()}\"",
    "Calculate area: pi * radius^2 or side^2"
  ],
  "visual_content": {
    "hierarchy_diagram": {
      "type": "inheritance_tree",
      "title": "Inheritance Hierarchy Example",
      "tree": {
        "root": "Shape",
        "children": [
          {
            "name": "Circle",
            "inherited": ["color", "display()"],
            "added": ["radius", "area()"],
            "overridden": ["display()"]
          },
          {
            "name": "Square",
            "inherited": ["color", "display()"],
            "added": ["side", "area()"],
            "overridden": ["display()"]
          }
        ]
      },
      "arrow_meaning": "→ inherits from",
      "example_code": "circle = Circle('red', 5)\\ncircle.color  # from Shape\\ncircle.area()  # from Circle\\ncircle.display()  # overridden in Circle"
    }
  }
}