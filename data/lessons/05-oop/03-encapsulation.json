{
  "module_id": 5,
  "title": "Encapsulation & Data Hiding",
  "order": 3,
  "reading_content": "\n<h3>Encapsulation in Python</h3>\n<p>Encapsulation is the bundling of data and methods that operate on that data, while restricting direct access to some components.</p>\n\n<h4>Public Attributes (Default):</h4>\n<pre><code># All attributes are public by default in Python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name  # Public attribute\n        self.age = age    # Public attribute\n\nalice = Person(\"Alice\", 25)\n\n# Direct access (allowed)\nprint(alice.name)  # Alice\nalice.age = 26     # Direct modification (allowed)\nprint(alice.age)   # 26\n\n# No restrictions - can even set invalid data!\nalice.age = -5     # ‚ùå Invalid but allowed!\nprint(alice.age)   # -5\n</code></pre>\n\n<h4>Protected Attributes (Convention: Single Underscore):</h4>\n<pre><code># Single underscore _ indicates \"protected\" (convention only)\nclass BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self._balance = balance  # \"Protected\" attribute (convention)\n    \n    def get_balance(self):\n        return self._balance\n    \n    def deposit(self, amount):\n        if amount > 0:\n            self._balance += amount\n\naccount = BankAccount(\"Alice\", 1000)\n\n# Use methods (recommended)\nprint(account.get_balance())  # 1000\naccount.deposit(500)\nprint(account.get_balance())  # 1500\n\n# Direct access still possible (but discouraged)\nprint(account._balance)  # 1500 (works, but violates convention)\naccount._balance = 999999  # Not recommended!\n</code></pre>\n\n<h4>Private Attributes (Name Mangling: Double Underscore):</h4>\n<pre><code># Double underscore __ triggers name mangling\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.__password = password  # \"Private\" attribute\n    \n    def check_password(self, password):\n        return self.__password == password\n    \n    def change_password(self, old_password, new_password):\n        if self.check_password(old_password):\n            self.__password = new_password\n            return \"Password changed\"\n        return \"Incorrect password\"\n\nuser = User(\"alice\", \"secret123\")\n\n# Use public methods\nprint(user.check_password(\"secret123\"))  # True\nprint(user.change_password(\"secret123\", \"newpass456\"))  # Password changed\n\n# Direct access doesn't work\n# print(user.__password)  # ‚ùå AttributeError\n\n# But can still access via name mangling (not recommended!)\nprint(user._User__password)  # newpass456 (name mangled to _ClassName__attribute)\n</code></pre>\n\n<h4>Property Decorators for Encapsulation:</h4>\n<pre><code># Use @property for controlled access\nclass Person:\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n    \n    @property\n    def name(self):\n        \"\"\"Getter for name.\"\"\"\n        return self._name\n    \n    @name.setter\n    def name(self, value):\n        \"\"\"Setter with validation.\"\"\"\n        if not isinstance(value, str):\n            raise TypeError(\"Name must be a string\")\n        if len(value) == 0:\n            raise ValueError(\"Name cannot be empty\")\n        self._name = value\n    \n    @property\n    def age(self):\n        \"\"\"Getter for age.\"\"\"\n        return self._age\n    \n    @age.setter\n    def age(self, value):\n        \"\"\"Setter with validation.\"\"\"\n        if not isinstance(value, int):\n            raise TypeError(\"Age must be an integer\")\n        if value < 0 or value > 150:\n            raise ValueError(\"Age must be between 0 and 150\")\n        self._age = value\n\nalice = Person(\"Alice\", 25)\n\n# Use like attributes (but calls getter/setter)\nprint(alice.name)  # Alice (calls getter)\nalice.age = 26     # Calls setter with validation\nprint(alice.age)   # 26\n\n# Validation works\ntry:\n    alice.age = -5   # ‚ùå ValueError: Age must be between 0 and 150\nexcept ValueError as e:\n    print(e)\n\ntry:\n    alice.name = \"\"  # ‚ùå ValueError: Name cannot be empty\nexcept ValueError as e:\n    print(e)\n</code></pre>\n\n<h4>Read-Only Properties:</h4>\n<pre><code># Property without setter is read-only\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n    \n    @property\n    def radius(self):\n        return self._radius\n    \n    @property\n    def diameter(self):\n        \"\"\"Computed property (read-only).\"\"\"\n        return self._radius * 2\n    \n    @property\n    def area(self):\n        \"\"\"Computed property (read-only).\"\"\"\n        return 3.14159 * self._radius ** 2\n    \n    @property\n    def circumference(self):\n        \"\"\"Computed property (read-only).\"\"\"\n        return 2 * 3.14159 * self._radius\n\ncircle = Circle(5)\n\n# Read properties\nprint(circle.radius)         # 5\nprint(circle.diameter)       # 10\nprint(circle.area)           # 78.53975\nprint(circle.circumference)  # 31.4159\n\n# Can't modify computed properties\n# circle.diameter = 20  # ‚ùå AttributeError: can't set attribute\n</code></pre>\n\n<h4>Practical Example - Temperature Class:</h4>\n<pre><code>class Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n    \n    @property\n    def celsius(self):\n        \"\"\"Get temperature in Celsius.\"\"\"\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        \"\"\"Set temperature in Celsius with validation.\"\"\"\n        if value < -273.15:\n            raise ValueError(\"Temperature below absolute zero!\")\n        self._celsius = value\n    \n    @property\n    def fahrenheit(self):\n        \"\"\"Get temperature in Fahrenheit (computed).\"\"\"\n        return (self._celsius * 9/5) + 32\n    \n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        \"\"\"Set temperature using Fahrenheit.\"\"\"\n        celsius = (value - 32) * 5/9\n        if celsius < -273.15:\n            raise ValueError(\"Temperature below absolute zero!\")\n        self._celsius = celsius\n    \n    @property\n    def kelvin(self):\n        \"\"\"Get temperature in Kelvin (computed).\"\"\"\n        return self._celsius + 273.15\n    \n    def __str__(self):\n        return f\"{self._celsius}¬∞C / {self.fahrenheit}¬∞F / {self.kelvin}K\"\n\ntemp = Temperature(25)\nprint(temp)  # 25¬∞C / 77.0¬∞F / 298.15K\n\n# Set using Celsius\ntemp.celsius = 30\nprint(temp.fahrenheit)  # 86.0\n\n# Set using Fahrenheit\ntemp.fahrenheit = 32\nprint(temp.celsius)  # 0.0\n\n# Validation works\ntry:\n    temp.celsius = -300  # ‚ùå ValueError\nexcept ValueError as e:\n    print(e)  # Temperature below absolute zero!\n</code></pre>\n\n<h4>Getters and Setters (Traditional Approach):</h4>\n<pre><code># You can use explicit getter/setter methods (less Pythonic)\nclass Rectangle:\n    def __init__(self, width, height):\n        self.__width = width\n        self.__height = height\n    \n    def get_width(self):\n        \"\"\"Getter for width.\"\"\"\n        return self.__width\n    \n    def set_width(self, value):\n        \"\"\"Setter for width with validation.\"\"\"\n        if value <= 0:\n            raise ValueError(\"Width must be positive\")\n        self.__width = value\n    \n    def get_height(self):\n        \"\"\"Getter for height.\"\"\"\n        return self.__height\n    \n    def set_height(self, value):\n        \"\"\"Setter for height with validation.\"\"\"\n        if value <= 0:\n            raise ValueError(\"Height must be positive\")\n        self.__height = value\n    \n    def area(self):\n        return self.__width * self.__height\n\nrect = Rectangle(5, 3)\nprint(rect.get_width())  # 5\nrect.set_width(10)\nprint(rect.area())  # 30\n\n# But @property is more Pythonic!\n</code></pre>\n\n<h4>Encapsulation Best Practices:</h4>\n<pre><code>class BankAccount:\n    \"\"\"Well-encapsulated bank account class.\"\"\"\n    \n    def __init__(self, owner, initial_balance=0):\n        self._owner = owner  # Protected (use property)\n        self.__balance = initial_balance  # Private (internal only)\n        self.__transaction_history = []  # Private\n    \n    @property\n    def owner(self):\n        \"\"\"Owner is read-only after creation.\"\"\"\n        return self._owner\n    \n    @property\n    def balance(self):\n        \"\"\"Balance is read-only (modify via deposit/withdraw).\"\"\"\n        return self.__balance\n    \n    def deposit(self, amount):\n        \"\"\"Public method with validation.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"Deposit amount must be positive\")\n        self.__balance += amount\n        self.__transaction_history.append(f\"Deposit: +${amount}\")\n        return self.__balance\n    \n    def withdraw(self, amount):\n        \"\"\"Public method with validation.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive\")\n        if amount > self.__balance:\n            raise ValueError(\"Insufficient funds\")\n        self.__balance -= amount\n        self.__transaction_history.append(f\"Withdrawal: -${amount}\")\n        return self.__balance\n    \n    def get_transaction_history(self):\n        \"\"\"Return copy of history (don't expose internal list).\"\"\"\n        return self.__transaction_history.copy()\n    \n    def __str__(self):\n        return f\"Account({self._owner}, Balance: ${self.__balance})\"\n\n# Usage\naccount = BankAccount(\"Alice\", 1000)\nprint(account.balance)  # 1000 (read-only property)\naccount.deposit(500)\naccount.withdraw(200)\nprint(account.balance)  # 1300\nprint(account.get_transaction_history())  # ['Deposit: +$500', 'Withdrawal: -$200']\n\n# Can't directly modify balance\n# account.balance = 999999  # ‚ùå AttributeError: can't set attribute\n\n# Can't directly modify owner\n# account.owner = \"Hacker\"  # ‚ùå AttributeError: can't set attribute\n</code></pre>\n\n<h4>When to Use Each Level:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Convention</th>\n        <th>Syntax</th>\n        <th>Access Level</th>\n        <th>Use Case</th>\n    </tr>\n    <tr>\n        <td><strong>Public</strong></td>\n        <td>attribute</td>\n        <td>Fully accessible</td>\n        <td>Part of class's public interface</td>\n    </tr>\n    <tr>\n        <td><strong>Protected</strong></td>\n        <td>_attribute</td>\n        <td>Accessible but discouraged</td>\n        <td>Internal use, subclass access</td>\n    </tr>\n    <tr>\n        <td><strong>Private</strong></td>\n        <td>__attribute</td>\n        <td>Name mangled</td>\n        <td>Truly internal, avoid conflicts</td>\n    </tr>\n    <tr>\n        <td><strong>Property</strong></td>\n        <td>@property</td>\n        <td>Controlled access</td>\n        <td>Validation, computed values</td>\n    </tr>\n</table>\n        ",
  "starter_code": "# TODO: Create a 'Student' class with encapsulation:\n# 1. __init__(name, grade) - store as protected attributes _name and _grade\n# 2. @property name - getter that returns _name\n# 3. @property grade - getter that returns _grade\n# 4. @grade.setter - setter with validation (0-100)\n# 5. If grade < 0 or > 100, raise ValueError\n#\n# Test:\n# student = Student(\"Alice\", 85)\n# print(student.name)   # Alice\n# print(student.grade)  # 85\n# student.grade = 92    # Works\n# print(student.grade)  # 92\n# student.grade = 150   # Should raise ValueError\n\n",
  "solution_code": "class Student:\n    def __init__(self, name, grade):\n        self._name = name\n        self._grade = grade\n    \n    @property\n    def name(self):\n        return self._name\n    \n    @property\n    def grade(self):\n        return self._grade\n    \n    @grade.setter\n    def grade(self, value):\n        if value < 0 or value > 100:\n            raise ValueError(\"Grade must be between 0 and 100\")\n        self._grade = value\n\nstudent = Student(\"Alice\", 85)\nprint(student.name)\nprint(student.grade)\nstudent.grade = 92\nprint(student.grade)\ntry:\n    student.grade = 150\nexcept ValueError as e:\n    print(e)",
  "learning_objectives": [
    "Understand public, protected, and private attribute conventions",
    "Use @property decorator to control attribute access",
    "Implement getters and setters with validation",
    "Apply encapsulation to protect data integrity"
  ],
  "key_concepts": [
    "Encapsulation",
    "Data Hiding",
    "Public Attributes",
    "Protected (_attribute)",
    "Private (__attribute)",
    "@property Decorator",
    "Getters and Setters",
    "Name Mangling"
  ],
  "test_cases": [
    {
      "name": "Test: Student with validation",
      "input": "",
      "expected_output": "Alice\n85\n92\nGrade must be between 0 and 100"
    }
  ],
  "hints": [
    "Store as protected: self._name, self._grade in __init__",
    "Create getter: @property def grade(self): return self._grade",
    "Create setter: @grade.setter def grade(self, value):",
    "Validate in setter: if value < 0 or value > 100: raise ValueError",
    "Properties are accessed like attributes: student.grade = 92"
  ],
  "visual_content": {
    "comparison_diagram": {
      "type": "access_levels",
      "levels": [
        {
          "name": "Public",
          "syntax": "self.attribute",
          "symbol": "‚úì Fully accessible",
          "example": "class Person:\\n    def __init__(self):\\n        self.name = 'Alice'  # Anyone can access/modify"
        },
        {
          "name": "Protected",
          "syntax": "self._attribute",
          "symbol": "‚ö† Convention only",
          "example": "class Person:\\n    def __init__(self):\\n        self._age = 25  # Discouraged but possible"
        },
        {
          "name": "Private",
          "syntax": "self.__attribute",
          "symbol": "üîí Name mangled",
          "example": "class Person:\\n    def __init__(self):\\n        self.__ssn = '123'  # Harder to access"
        },
        {
          "name": "Property",
          "syntax": "@property",
          "symbol": "üõ° Controlled access",
          "example": "@property\\ndef age(self):\\n    return self._age  # With validation"
        }
      ]
    }
  }
}