{
  "module_id": 5,
  "title": "Polymorphism & Duck Typing",
  "order": 5,
  "reading_content": "\n<h3>Polymorphism in Python</h3>\n<p>Polymorphism allows objects of different classes to be treated as objects of a common parent class, enabling flexible and reusable code.</p>\n\n<h4>Method Polymorphism:</h4>\n<pre><code># Same method name, different implementations\nclass Dog:\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat:\n    def speak(self):\n        return \"Meow!\"\n\nclass Cow:\n    def speak(self):\n        return \"Moo!\"\n\n# Polymorphic function - works with any object that has speak()\ndef animal_sound(animal):\n    print(animal.speak())\n\ndog = Dog()\ncat = Cat()\ncow = Cow()\n\nanimal_sound(dog)  # Woof!\nanimal_sound(cat)  # Meow!\nanimal_sound(cow)  # Moo!\n</code></pre>\n\n<h4>Polymorphism with Inheritance:</h4>\n<pre><code>class Animal:\n    def speak(self):\n        return \"Some sound\"\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\n# Function accepts any Animal\ndef make_sound(animal: Animal):\n    print(animal.speak())\n\nanimals = [Dog(), Cat(), Animal()]\n\nfor animal in animals:\n    make_sound(animal)\n# Output:\n# Woof!\n# Meow!\n# Some sound\n</code></pre>\n\n<h4>Duck Typing - \"If it walks like a duck...\":</h4>\n<pre><code># Python uses duck typing - doesn't check type, just checks if method exists\nclass Duck:\n    def swim(self):\n        return \"Duck swimming\"\n    \n    def fly(self):\n        return \"Duck flying\"\n\nclass Airplane:\n    def fly(self):\n        return \"Airplane flying\"\n\nclass Whale:\n    def swim(self):\n        return \"Whale swimming\"\n\n# Polymorphic function - works with anything that can fly\ndef make_it_fly(thing):\n    return thing.fly()\n\n# Polymorphic function - works with anything that can swim\ndef make_it_swim(thing):\n    return thing.swim()\n\nduck = Duck()\nplane = Airplane()\nwhale = Whale()\n\nprint(make_it_fly(duck))   # Duck flying\nprint(make_it_fly(plane))  # Airplane flying\n# print(make_it_fly(whale))  # ❌ AttributeError: no fly() method\n\nprint(make_it_swim(duck))  # Duck swimming\nprint(make_it_swim(whale)) # Whale swimming\n# print(make_it_swim(plane))  # ❌ AttributeError: no swim() method\n</code></pre>\n\n<h4>Operator Overloading (Special Methods):</h4>\n<pre><code># Polymorphism with operators\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):\n        \"\"\"Overload + operator.\"\"\"\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __mul__(self, scalar):\n        \"\"\"Overload * operator.\"\"\"\n        return Vector(self.x * scalar, self.y * scalar)\n    \n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv1 = Vector(2, 3)\nv2 = Vector(4, 5)\n\nv3 = v1 + v2  # Uses __add__\nprint(v3)     # Vector(6, 8)\n\nv4 = v1 * 3   # Uses __mul__\nprint(v4)     # Vector(6, 9)\n</code></pre>\n\n<h4>Practical Example - Payment System:</h4>\n<pre><code>class PaymentProcessor:\n    \"\"\"Base class for payment processing.\"\"\"\n    \n    def pay(self, amount):\n        raise NotImplementedError(\"Subclass must implement pay()\")\n\nclass CreditCardPayment(PaymentProcessor):\n    def __init__(self, card_number):\n        self.card_number = card_number\n    \n    def pay(self, amount):\n        return f\"Paid ${amount} with credit card ending in {self.card_number[-4:]}\"\n\nclass PayPalPayment(PaymentProcessor):\n    def __init__(self, email):\n        self.email = email\n    \n    def pay(self, amount):\n        return f\"Paid ${amount} via PayPal ({self.email})\"\n\nclass BitcoinPayment(PaymentProcessor):\n    def __init__(self, wallet_address):\n        self.wallet_address = wallet_address\n    \n    def pay(self, amount):\n        return f\"Paid ${amount} in Bitcoin to {self.wallet_address[:10]}...\"\n\n# Polymorphic function\ndef process_payment(payment_method: PaymentProcessor, amount: float):\n    print(payment_method.pay(amount))\n\n# Works with any payment method\ncc = CreditCardPayment(\"1234567890123456\")\npaypal = PayPalPayment(\"user@example.com\")\nbtc = BitcoinPayment(\"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\")\n\nprocess_payment(cc, 100.00)      # Credit card\nprocess_payment(paypal, 50.00)   # PayPal\nprocess_payment(btc, 0.001)      # Bitcoin\n</code></pre>\n\n<h4>Abstract Base Classes for Polymorphism:</h4>\n<pre><code>from abc import ABC, abstractmethod\n\nclass Database(ABC):\n    \"\"\"Abstract base class for databases.\"\"\"\n    \n    @abstractmethod\n    def connect(self):\n        pass\n    \n    @abstractmethod\n    def query(self, sql):\n        pass\n    \n    @abstractmethod\n    def close(self):\n        pass\n\nclass MySQL(Database):\n    def connect(self):\n        return \"Connected to MySQL\"\n    \n    def query(self, sql):\n        return f\"Executing MySQL query: {sql}\"\n    \n    def close(self):\n        return \"MySQL connection closed\"\n\nclass PostgreSQL(Database):\n    def connect(self):\n        return \"Connected to PostgreSQL\"\n    \n    def query(self, sql):\n        return f\"Executing PostgreSQL query: {sql}\"\n    \n    def close(self):\n        return \"PostgreSQL connection closed\"\n\n# Polymorphic function\ndef run_database_operation(db: Database, query: str):\n    print(db.connect())\n    print(db.query(query))\n    print(db.close())\n\nmysql = MySQL()\npostgres = PostgreSQL()\n\nrun_database_operation(mysql, \"SELECT * FROM users\")\nprint()\nrun_database_operation(postgres, \"SELECT * FROM users\")\n</code></pre>\n\n<h4>Polymorphism with Collections:</h4>\n<pre><code># List of different types, common interface\nclass Shape:\n    def area(self):\n        raise NotImplementedError\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14159 * self.radius ** 2\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass Triangle(Shape):\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n    \n    def area(self):\n        return 0.5 * self.base * self.height\n\n# List of different shapes\nshapes = [\n    Circle(5),\n    Rectangle(4, 6),\n    Triangle(3, 8),\n    Circle(3)\n]\n\n# Calculate total area polymorphically\ntotal_area = sum(shape.area() for shape in shapes)\nprint(f\"Total area: {total_area:.2f}\")  # 124.85\n\nfor shape in shapes:\n    print(f\"{shape.__class__.__name__}: {shape.area():.2f}\")\n# Output:\n# Circle: 78.54\n# Rectangle: 24.00\n# Triangle: 12.00\n# Circle: 28.27\n</code></pre>\n\n<h4>Type Checking with isinstance():</h4>\n<pre><code># Sometimes you need to check types\ndef process_data(data):\n    if isinstance(data, str):\n        return data.upper()\n    elif isinstance(data, int):\n        return data * 2\n    elif isinstance(data, list):\n        return len(data)\n    else:\n        return \"Unknown type\"\n\nprint(process_data(\"hello\"))    # HELLO\nprint(process_data(10))         # 20\nprint(process_data([1, 2, 3]))  # 3\nprint(process_data(3.14))       # Unknown type\n</code></pre>\n\n<h4>EAFP vs LBYL:</h4>\n<pre><code># LBYL: Look Before You Leap (check type first)\ndef make_sound_lbyl(animal):\n    if hasattr(animal, 'speak'):\n        print(animal.speak())\n    else:\n        print(\"This animal can't speak\")\n\n# EAFP: Easier to Ask for Forgiveness than Permission (try it)\ndef make_sound_eafp(animal):\n    try:\n        print(animal.speak())\n    except AttributeError:\n        print(\"This animal can't speak\")\n\n# EAFP is more Pythonic\nclass Dog:\n    def speak(self):\n        return \"Woof!\"\n\nclass Rock:\n    pass\n\nmake_sound_eafp(Dog())  # Woof!\nmake_sound_eafp(Rock()) # This animal can't speak\n</code></pre>\n\n<h4>Practical Benefits:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Benefit</th>\n        <th>Example</th>\n    </tr>\n    <tr>\n        <td><strong>Flexibility</strong></td>\n        <td>Add new classes without changing existing code</td>\n    </tr>\n    <tr>\n        <td><strong>Reusability</strong></td>\n        <td>Same function works with multiple types</td>\n    </tr>\n    <tr>\n        <td><strong>Maintainability</strong></td>\n        <td>Changes to one class don't affect others</td>\n    </tr>\n    <tr>\n        <td><strong>Extensibility</strong></td>\n        <td>Easy to add new payment methods, shapes, etc.</td>\n    </tr>\n</table>\n\n<h4>Key Principles:</h4>\n<pre><code># 1. Program to an interface, not an implementation\ndef process(handler):  # Accept any handler\n    handler.handle()   # Not specific to one class\n\n# 2. Favor composition over inheritance (when appropriate)\n# 3. Open/Closed Principle: Open for extension, closed for modification\n# 4. Liskov Substitution: Child classes should work wherever parent works\n</code></pre>\n        ",
  "starter_code": "# TODO: Create a polymorphic drawing application:\n# 1. Create base class 'Shape' with method draw() that raises NotImplementedError\n# 2. Create 'Circle' class that inherits Shape and implements draw() to return \"Drawing a circle\"\n# 3. Create 'Square' class that inherits Shape and implements draw() to return \"Drawing a square\"\n# 4. Create 'Triangle' class that inherits Shape and implements draw() to return \"Drawing a triangle\"\n# 5. Create function draw_all(shapes) that takes a list of shapes and calls draw() on each\n#\n# Test:\n# shapes = [Circle(), Square(), Triangle(), Circle()]\n# draw_all(shapes)\n# Output:\n# Drawing a circle\n# Drawing a square\n# Drawing a triangle\n# Drawing a circle\n\n",
  "solution_code": "class Shape:\n    def draw(self):\n        raise NotImplementedError(\"Subclass must implement draw()\")\n\nclass Circle(Shape):\n    def draw(self):\n        return \"Drawing a circle\"\n\nclass Square(Shape):\n    def draw(self):\n        return \"Drawing a square\"\n\nclass Triangle(Shape):\n    def draw(self):\n        return \"Drawing a triangle\"\n\ndef draw_all(shapes):\n    for shape in shapes:\n        print(shape.draw())\n\nshapes = [Circle(), Square(), Triangle(), Circle()]\ndraw_all(shapes)",
  "learning_objectives": [
    "Understand polymorphism and its benefits",
    "Implement method polymorphism across different classes",
    "Apply duck typing in Python",
    "Use abstract base classes to enforce polymorphic interfaces"
  ],
  "key_concepts": [
    "Polymorphism",
    "Duck Typing",
    "Method Overriding",
    "Abstract Base Classes",
    "isinstance()",
    "EAFP vs LBYL",
    "Interface-based Programming"
  ],
  "test_cases": [
    {
      "name": "Test: Polymorphic drawing",
      "input": "",
      "expected_output": "Drawing a circle\nDrawing a square\nDrawing a triangle\nDrawing a circle"
    }
  ],
  "hints": [
    "Base class: class Shape: def draw(self): raise NotImplementedError()",
    "Child classes override draw(): def draw(self): return \"Drawing a circle\"",
    "draw_all function: for shape in shapes: print(shape.draw())",
    "Each shape implements the same interface (draw method)"
  ],
  "visual_content": {
    "diagram": {
      "type": "polymorphism_concept",
      "title": "Polymorphism in Action",
      "example": {
        "interface": "def process(handler):\\n    handler.handle()  # Same call",
        "implementations": [
          {"class": "FileHandler", "method": "handle() → Save to file"},
          {"class": "DatabaseHandler", "method": "handle() → Save to database"},
          {"class": "APIHandler", "method": "handle() → Send to API"}
        ],
        "benefit": "One function, multiple behaviors"
      },
      "duck_typing": {
        "principle": "If it looks like a duck and quacks like a duck, it's a duck",
        "code": "def make_it_quack(thing):\\n    thing.quack()  # Don't care about type, just that it has quack()",
        "works_with": ["Duck", "Robot (with quack method)", "Toy (with quack method)"]
      }
    }
  }
}