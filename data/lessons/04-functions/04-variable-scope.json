{
  "module_id": 4,
  "title": "Variable Scope & LEGB Rule",
  "order": 4,
  "reading_content": "\n<h3>Understanding Variable Scope</h3>\n<p>Scope determines where variables can be accessed in your code. Python uses the LEGB rule: Local, Enclosing, Global, Built-in.</p>\n\n<h4>Local Scope:</h4>\n<pre><code># Variables defined inside a function are local\ndef my_function():\n    x = 10  # Local variable\n    print(x)  # 10\n\nmy_function()\n# print(x)  # ❌ NameError: x is not defined (outside function scope)\n\n# Each function call creates new local scope\ndef counter():\n    count = 0\n    count += 1\n    return count\n\nprint(counter())  # 1\nprint(counter())  # 1 (not 2! Each call has separate scope)\n</code></pre>\n\n<h4>Global Scope:</h4>\n<pre><code># Variables defined at module level are global\nx = 100  # Global variable\n\ndef print_x():\n    print(x)  # Can read global variable\n\nprint_x()  # 100\nprint(x)   # 100 (accessible everywhere)\n\n# Functions create new local variables by default\ny = 200\n\ndef modify_y():\n    y = 300  # Creates NEW local variable (doesn't modify global)\n    print(f\"Inside: {y}\")  # 300\n\nmodify_y()\nprint(f\"Outside: {y}\")  # 200 (global unchanged)\n</code></pre>\n\n<h4>The global Keyword:</h4>\n<pre><code># Use 'global' to modify global variables\ncounter = 0\n\ndef increment():\n    global counter  # Tells Python to use global variable\n    counter += 1\n    print(f\"Counter: {counter}\")\n\nincrement()  # Counter: 1\nincrement()  # Counter: 2\nincrement()  # Counter: 3\nprint(counter)  # 3 (global was modified)\n\n# Multiple global variables\nx = 10\ny = 20\n\ndef modify_both():\n    global x, y\n    x = 100\n    y = 200\n\nmodify_both()\nprint(x, y)  # 100 200\n</code></pre>\n\n<h4>Enclosing Scope (Nested Functions):</h4>\n<pre><code># Inner function can access outer function's variables\ndef outer():\n    x = \"outer\"  # Enclosing scope\n    \n    def inner():\n        print(x)  # Can access outer's x\n    \n    inner()\n\nouter()  # outer\n\n# Multiple levels\ndef level1():\n    x = \"level 1\"\n    \n    def level2():\n        y = \"level 2\"\n        \n        def level3():\n            print(x)  # Accesses level1's x\n            print(y)  # Accesses level2's y\n        \n        level3()\n    \n    level2()\n\nlevel1()\n# Output:\n# level 1\n# level 2\n</code></pre>\n\n<h4>The nonlocal Keyword:</h4>\n<pre><code># Use 'nonlocal' to modify enclosing scope variables\ndef outer():\n    count = 0\n    \n    def increment():\n        nonlocal count  # Modify outer's count\n        count += 1\n        return count\n    \n    print(increment())  # 1\n    print(increment())  # 2\n    print(increment())  # 3\n\nouter()\n\n# Create closure with state\ndef create_counter():\n    count = 0\n    \n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    \n    return increment\n\ncounter1 = create_counter()\nprint(counter1())  # 1\nprint(counter1())  # 2\n\ncounter2 = create_counter()  # New counter\nprint(counter2())  # 1 (separate state!)\n</code></pre>\n\n<h4>LEGB Rule Visualization:</h4>\n<pre><code># L: Local (current function)\n# E: Enclosing (outer functions)\n# G: Global (module level)\n# B: Built-in (Python built-ins like print, len)\n\nx = \"global\"  # Global scope\n\ndef outer():\n    x = \"enclosing\"  # Enclosing scope\n    \n    def inner():\n        x = \"local\"  # Local scope\n        print(x)  # Prints \"local\" (L takes precedence)\n    \n    inner()\n    print(x)  # Prints \"enclosing\" (E scope)\n\nouter()\nprint(x)  # Prints \"global\" (G scope)\n\n# Python searches: Local → Enclosing → Global → Built-in\ndef scope_demo():\n    # print is built-in (B)\n    # If no local 'print', Python finds built-in\n    print(\"Hello\")  # Uses built-in print\n    \n    # Override built-in (not recommended!)\n    print = \"I'm not a function anymore!\"\n    # print(\"Hello\")  # ❌ TypeError: str is not callable\n\nscope_demo()\n</code></pre>\n\n<h4>Common Scope Issues:</h4>\n<pre><code># Issue 1: UnboundLocalError\nx = 10\n\ndef modify_x():\n    print(x)  # Tries to access x\n    x = 20    # But this makes x local!\n    # ❌ UnboundLocalError: local variable 'x' referenced before assignment\n\n# modify_x()\n\n# Solution: Use global keyword\ndef modify_x_correct():\n    global x\n    print(x)\n    x = 20\n\nmodify_x_correct()  # Works!\n\n# Issue 2: Mutable default arguments\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [1, 2] - Unexpected!\nprint(add_item(3))  # [1, 2, 3] - Same list!\n\n# Solution: Use None as default\ndef add_item_correct(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\nprint(add_item_correct(1))  # [1]\nprint(add_item_correct(2))  # [2] - Correct!\n</code></pre>\n\n<h4>Practical Examples:</h4>\n<pre><code># Example 1: Configuration with closure\ndef create_logger(prefix):\n    def log(message):\n        print(f\"[{prefix}] {message}\")\n    return log\n\ninfo_log = create_logger(\"INFO\")\nerror_log = create_logger(\"ERROR\")\n\ninfo_log(\"Application started\")  # [INFO] Application started\nerror_log(\"Connection failed\")   # [ERROR] Connection failed\n\n# Example 2: Accumulator\ndef create_accumulator():\n    total = 0\n    \n    def add(value):\n        nonlocal total\n        total += value\n        return total\n    \n    return add\n\nacc = create_accumulator()\nprint(acc(10))  # 10\nprint(acc(20))  # 30\nprint(acc(5))   # 35\n\n# Example 3: Module-level configuration\nDEBUG = True  # Global configuration\n\ndef debug_log(message):\n    if DEBUG:\n        print(f\"DEBUG: {message}\")\n\ndef process_data(data):\n    debug_log(\"Processing started\")  # Uses global DEBUG\n    # Process data...\n    debug_log(\"Processing completed\")\n\nprocess_data([1, 2, 3])\n</code></pre>\n\n<h4>Best Practices:</h4>\n<pre><code># ✓ Good: Minimize global variables\ndef calculate_total(prices, tax_rate):\n    subtotal = sum(prices)\n    return subtotal * (1 + tax_rate)\n\n# ✗ Avoid: Too many globals\n# prices = [10, 20, 30]\n# tax_rate = 0.08\n# def calculate_total():\n#     global prices, tax_rate  # Harder to test and maintain\n#     ...\n\n# ✓ Good: Pass data as parameters\ndef process(data, config):\n    # Clear what function needs\n    return data * config['multiplier']\n\n# ✓ Good: Return values instead of modifying globals\ndef get_tax(amount):\n    return amount * 0.08  # Return instead of modifying global\n\n# ✓ Good: Use closures for encapsulation\ndef create_validator(min_val, max_val):\n    def validate(value):\n        return min_val <= value <= max_val\n    return validate\n\nage_validator = create_validator(0, 120)\nprint(age_validator(25))  # True\n</code></pre>\n\n<h4>Scope Quick Reference:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Scope</th>\n        <th>Where Defined</th>\n        <th>Access From</th>\n        <th>Modify With</th>\n    </tr>\n    <tr>\n        <td><strong>Local (L)</strong></td>\n        <td>Inside function</td>\n        <td>Only that function</td>\n        <td>Direct assignment</td>\n    </tr>\n    <tr>\n        <td><strong>Enclosing (E)</strong></td>\n        <td>Outer function</td>\n        <td>Inner functions</td>\n        <td>nonlocal keyword</td>\n    </tr>\n    <tr>\n        <td><strong>Global (G)</strong></td>\n        <td>Module level</td>\n        <td>Everywhere in module</td>\n        <td>global keyword</td>\n    </tr>\n    <tr>\n        <td><strong>Built-in (B)</strong></td>\n        <td>Python internals</td>\n        <td>Everywhere</td>\n        <td>Don't modify!</td>\n    </tr>\n</table>\n        ",
  "starter_code": "# TODO:\n# 1. Create a global variable 'total' set to 0\n# 2. Create a function 'add_to_total' that takes a 'value' parameter\n# 3. Use 'global' keyword to modify the global 'total'\n# 4. Add the value to total\n# 5. Call the function 3 times with values: 10, 20, 30\n# 6. Print the final total (should be 60)\n\n",
  "solution_code": "total = 0\n\ndef add_to_total(value):\n    global total\n    total += value\n\nadd_to_total(10)\nadd_to_total(20)\nadd_to_total(30)\n\nprint(total)",
  "learning_objectives": [
    "Understand the difference between local and global scope",
    "Use the global keyword to modify global variables",
    "Apply the nonlocal keyword in nested functions",
    "Follow the LEGB rule for variable resolution"
  ],
  "key_concepts": [
    "Variable Scope",
    "Local Scope",
    "Global Scope",
    "Enclosing Scope",
    "LEGB Rule",
    "global Keyword",
    "nonlocal Keyword",
    "Closures"
  ],
  "test_cases": [
    {
      "name": "Test: Global accumulator",
      "input": "",
      "expected_output": "60"
    }
  ],
  "hints": [
    "Define global variable: total = 0",
    "In function, use: global total",
    "Add to total: total += value",
    "Call function 3 times with different values",
    "Print total at the end"
  ],
  "visual_content": {
    "diagram": {
      "type": "scope_hierarchy",
      "title": "LEGB Rule Lookup Order",
      "levels": [
        {
          "level": "Local (L)",
          "priority": 1,
          "description": "Current function",
          "example": "def func():\\n    x = 10  # Local"
        },
        {
          "level": "Enclosing (E)",
          "priority": 2,
          "description": "Outer functions",
          "example": "def outer():\\n    x = 20\\n    def inner():\\n        print(x)  # Enclosing"
        },
        {
          "level": "Global (G)",
          "priority": 3,
          "description": "Module level",
          "example": "x = 30  # Global"
        },
        {
          "level": "Built-in (B)",
          "priority": 4,
          "description": "Python built-ins",
          "example": "print, len, sum, etc."
        }
      ],
      "search_order": "Python searches L → E → G → B until variable is found"
    }
  }
}
