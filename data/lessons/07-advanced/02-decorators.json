{
  "module_id": 7,
  "title": "Decorators",
  "order": 2,
  "reading_content": "\n<h3>Python Decorators</h3>\n<p>Decorators are a powerful way to modify or enhance functions/classes without changing their source code. They wrap a function with additional functionality.</p>\n\n<h4>Functions as First-Class Objects:</h4>\n<pre><code># Functions can be assigned to variables\ndef greet():\n    return \"Hello!\"\n\nmessage = greet  # Assign function to variable\nprint(message())  # Hello!\n\n# Functions can be passed as arguments\ndef apply_twice(func, value):\n    return func(func(value))\n\ndef double(x):\n    return x * 2\n\nresult = apply_twice(double, 5)  # double(double(5)) = 20\nprint(result)  # 20\n\n# Functions can return functions\ndef make_multiplier(factor):\n    def multiplier(x):\n        return x * factor\n    return multiplier\n\ntimes_three = make_multiplier(3)\nprint(times_three(10))  # 30\n</code></pre>\n\n<h4>Basic Decorator:</h4>\n<pre><code># Decorator is a function that takes a function and returns a modified version\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before function\")\n        func()  # Call original function\n        print(\"After function\")\n    return wrapper\n\n# Manual decoration\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello = my_decorator(say_hello)  # Wrap the function\nsay_hello()\n# Output:\n# Before function\n# Hello!\n# After function\n\n# Using @ syntax (syntactic sugar)\n@my_decorator\ndef say_goodbye():\n    print(\"Goodbye!\")\n\nsay_goodbye()  # Automatically wrapped\n# Output:\n# Before function\n# Goodbye!\n# After function\n</code></pre>\n\n<h4>Decorator with Arguments:</h4>\n<pre><code># Decorator that handles function arguments\ndef smart_decorator(func):\n    def wrapper(*args, **kwargs):  # Accept any arguments\n        print(f\"Calling {func.__name__}\")\n        result = func(*args, **kwargs)  # Pass arguments to original\n        print(f\"Result: {result}\")\n        return result\n    return wrapper\n\n@smart_decorator\ndef add(a, b):\n    return a + b\n\n@smart_decorator\ndef greet(name, greeting=\"Hello\"):\n    return f\"{greeting}, {name}!\"\n\nprint(add(5, 3))\n# Calling add\n# Result: 8\n# 8\n\nprint(greet(\"Alice\", greeting=\"Hi\"))\n# Calling greet\n# Result: Hi, Alice!\n# Hi, Alice!\n</code></pre>\n\n<h4>Practical Decorator - Timing Functions:</h4>\n<pre><code>import time\n\ndef timer(func):\n    \"\"\"Measure execution time of function.\"\"\"\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end - start:.4f} seconds\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(1)\n    return \"Done!\"\n\n@timer\ndef calculate_sum(n):\n    return sum(range(n))\n\nprint(slow_function())  \n# slow_function took 1.0012 seconds\n# Done!\n\nprint(calculate_sum(1000000))\n# calculate_sum took 0.0234 seconds\n# 499999500000\n</code></pre>\n\n<h4>Practical Decorator - Logging:</h4>\n<pre><code>def log_calls(func):\n    \"\"\"Log function calls with arguments.\"\"\"\n    def wrapper(*args, **kwargs):\n        args_str = ', '.join(repr(arg) for arg in args)\n        kwargs_str = ', '.join(f\"{k}={v!r}\" for k, v in kwargs.items())\n        all_args = ', '.join(filter(None, [args_str, kwargs_str]))\n        print(f\"Calling {func.__name__}({all_args})\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} returned {result!r}\")\n        return result\n    return wrapper\n\n@log_calls\ndef divide(a, b):\n    return a / b\n\n@log_calls\ndef greet(name, greeting=\"Hello\"):\n    return f\"{greeting}, {name}\"\n\nprint(divide(10, 2))\n# Calling divide(10, 2)\n# divide returned 5.0\n# 5.0\n\nprint(greet(\"Bob\", greeting=\"Hi\"))\n# Calling greet('Bob', greeting='Hi')\n# greet returned 'Hi, Bob'\n# Hi, Bob\n</code></pre>\n\n<h4>Decorator with Parameters:</h4>\n<pre><code># Decorator factory - returns a decorator\ndef repeat(times):\n    \"\"\"Decorator that repeats function execution.\"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef say_hi():\n    print(\"Hi!\")\n\nsay_hi()\n# Hi!\n# Hi!\n# Hi!\n\n@repeat(times=5)\ndef count(n):\n    print(n)\n\ncount(1)\n# 1\n# 1\n# 1\n# 1\n# 1\n</code></pre>\n\n<h4>Multiple Decorators (Stacking):</h4>\n<pre><code>def bold(func):\n    def wrapper(*args, **kwargs):\n        return f\"<b>{func(*args, **kwargs)}</b>\"\n    return wrapper\n\ndef italic(func):\n    def wrapper(*args, **kwargs):\n        return f\"<i>{func(*args, **kwargs)}</i>\"\n    return wrapper\n\n@bold\n@italic\ndef hello():\n    return \"Hello, World!\"\n\nprint(hello())  # <b><i>Hello, World!</i></b>\n\n# Order matters! Applied from bottom to top:\n# 1. italic wraps hello\n# 2. bold wraps the result\n\n# Equivalent to:\n# hello = bold(italic(hello))\n</code></pre>\n\n<h4>Preserving Function Metadata with functools.wraps:</h4>\n<pre><code>import functools\n\n# Without functools.wraps\ndef bad_decorator(func):\n    def wrapper(*args, **kwargs):\n        \"\"\"Wrapper function.\"\"\"\n        return func(*args, **kwargs)\n    return wrapper\n\n@bad_decorator\ndef my_function():\n    \"\"\"My function docstring.\"\"\"\n    pass\n\nprint(my_function.__name__)  # wrapper (wrong!)\nprint(my_function.__doc__)   # Wrapper function. (wrong!)\n\n# With functools.wraps (correct way)\ndef good_decorator(func):\n    @functools.wraps(func)  # Preserves metadata\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@good_decorator\ndef my_function2():\n    \"\"\"My function docstring.\"\"\"\n    pass\n\nprint(my_function2.__name__)  # my_function2 (correct!)\nprint(my_function2.__doc__)   # My function docstring. (correct!)\n</code></pre>\n\n<h4>Practical Decorator - Authentication:</h4>\n<pre><code># Simulated authentication decorator\nlogged_in_user = None\n\ndef require_auth(func):\n    \"\"\"Require user to be logged in.\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if logged_in_user is None:\n            return \"Error: You must be logged in\"\n        return func(*args, **kwargs)\n    return wrapper\n\ndef require_admin(func):\n    \"\"\"Require user to be admin.\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if logged_in_user != 'admin':\n            return \"Error: Admin access required\"\n        return func(*args, **kwargs)\n    return wrapper\n\n@require_auth\ndef view_profile():\n    return f\"Profile of {logged_in_user}\"\n\n@require_admin\ndef delete_user(username):\n    return f\"User {username} deleted\"\n\nprint(view_profile())  # Error: You must be logged in\n\nlogged_in_user = 'alice'\nprint(view_profile())  # Profile of alice\nprint(delete_user('bob'))  # Error: Admin access required\n\nlogged_in_user = 'admin'\nprint(delete_user('bob'))  # User bob deleted\n</code></pre>\n\n<h4>Practical Decorator - Caching (Memoization):</h4>\n<pre><code>def memoize(func):\n    \"\"\"Cache function results.\"\"\"\n    cache = {}\n    \n    @functools.wraps(func)\n    def wrapper(*args):\n        if args not in cache:\n            print(f\"Computing {func.__name__}{args}\")\n            cache[args] = func(*args)\n        else:\n            print(f\"Using cached result for {func.__name__}{args}\")\n        return cache[args]\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    \"\"\"Calculate nth Fibonacci number (slow without cache).\"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(5))\n# Computing fibonacci(5)\n# Computing fibonacci(4)\n# Computing fibonacci(3)\n# Computing fibonacci(2)\n# Computing fibonacci(1)\n# Computing fibonacci(0)\n# Using cached result for fibonacci(1)\n# Using cached result for fibonacci(2)\n# Using cached result for fibonacci(3)\n# 5\n\n# Python's built-in version:\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci_fast(n):\n    if n < 2:\n        return n\n    return fibonacci_fast(n-1) + fibonacci_fast(n-2)\n\nprint(fibonacci_fast(100))  # Instant!\n</code></pre>\n\n<h4>Class Decorators:</h4>\n<pre><code># Decorator can also be a class\nclass CountCalls:\n    \"\"\"Count how many times function is called.\"\"\"\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"Call {self.count} to {self.func.__name__}\")\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()  # Call 1 to say_hello\nsay_hello()  # Call 2 to say_hello\nsay_hello()  # Call 3 to say_hello\n</code></pre>\n\n<h4>Common Built-in Decorators:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Decorator</th>\n        <th>Purpose</th>\n        <th>Example</th>\n    </tr>\n    <tr>\n        <td><strong>@property</strong></td>\n        <td>Define getter method</td>\n        <td>Access attribute like obj.name</td>\n    </tr>\n    <tr>\n        <td><strong>@staticmethod</strong></td>\n        <td>Method doesn't need self/cls</td>\n        <td>Utility functions in classes</td>\n    </tr>\n    <tr>\n        <td><strong>@classmethod</strong></td>\n        <td>Method receives class as first arg</td>\n        <td>Alternative constructors</td>\n    </tr>\n    <tr>\n        <td><strong>@functools.wraps</strong></td>\n        <td>Preserve function metadata</td>\n        <td>Used inside decorators</td>\n    </tr>\n    <tr>\n        <td><strong>@functools.lru_cache</strong></td>\n        <td>Cache function results</td>\n        <td>Expensive computations</td>\n    </tr>\n</table>\n\n<h4>Decorator Best Practices:</h4>\n<pre><code>import functools\n\n# ✅ Template for a good decorator\ndef my_decorator(func):\n    @functools.wraps(func)  # Preserve metadata\n    def wrapper(*args, **kwargs):  # Handle any arguments\n        # Before function\n        result = func(*args, **kwargs)\n        # After function\n        return result  # Return result\n    return wrapper\n\n# ✅ Decorator with parameters\ndef parametrized_decorator(param):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Use param here\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>\n        ",
  "starter_code": "# TODO: Create a decorator that validates function arguments:\n# Decorator: validate_positive\n# - Checks that all numeric arguments are positive (> 0)\n# - Raises ValueError if any argument is <= 0\n# - Otherwise, calls the original function\n# \n# Test:\n# @validate_positive\n# def calculate_area(length, width):\n#     return length * width\n# \n# print(calculate_area(5, 3))   # 15\n# print(calculate_area(-5, 3))  # ValueError: All arguments must be positive\n\n",
  "solution_code": "import functools\n\ndef validate_positive(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Check all arguments\n        for arg in args:\n            if isinstance(arg, (int, float)) and arg <= 0:\n                raise ValueError(\"All arguments must be positive\")\n        \n        for value in kwargs.values():\n            if isinstance(value, (int, float)) and value <= 0:\n                raise ValueError(\"All arguments must be positive\")\n        \n        return func(*args, **kwargs)\n    return wrapper\n\n@validate_positive\ndef calculate_area(length, width):\n    return length * width\n\nprint(calculate_area(5, 3))   # 15\n\ntry:\n    print(calculate_area(-5, 3))\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Error: All arguments must be positive",
  "learning_objectives": [
    "Understand decorators and the @ syntax",
    "Create decorators that wrap functions",
    "Use functools.wraps to preserve metadata",
    "Build decorators with parameters"
  ],
  "key_concepts": [
    "Decorators",
    "@ Syntax",
    "Wrapper Functions",
    "functools.wraps",
    "Decorator Parameters",
    "Stacking Decorators",
    "Class Decorators",
    "Built-in Decorators"
  ],
  "test_cases": [
    {
      "name": "Test: Validate positive decorator",
      "input": "",
      "expected_output": "15\nError: All arguments must be positive"
    }
  ],
  "hints": [
    "Decorator structure: def decorator(func): def wrapper(*args, **kwargs): ... return wrapper",
    "Use @functools.wraps(func) to preserve function metadata",
    "Check arguments: for arg in args: if isinstance(arg, (int, float)) and arg <= 0: ...",
    "Raise error: raise ValueError('message')",
    "Return original result: return func(*args, **kwargs)"
  ],
  "visual_content": {
    "diagram": {
      "type": "decorator_concept",
      "title": "How Decorators Work",
      "basic_pattern": "@decorator\\ndef func():\\n    pass\\n\\n# Equivalent to:\\nfunc = decorator(func)",
      "execution_flow": {
        "step1": "Original function defined",
        "step2": "Decorator wraps function",
        "step3": "Wrapped function replaces original",
        "step4": "Calling func() → calls wrapper → calls original"
      },
      "template": "import functools\\n\\ndef my_decorator(func):\\n    @functools.wraps(func)\\n    def wrapper(*args, **kwargs):\\n        # Before\\n        result = func(*args, **kwargs)\\n        # After\\n        return result\\n    return wrapper",
      "use_cases": [
        "Timing functions",
        "Logging calls",
        "Authentication/Authorization",
        "Caching results",
        "Input validation",
        "Rate limiting"
      ]
    }
  }
}