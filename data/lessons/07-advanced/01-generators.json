{
  "module_id": 7,
  "title": "Generators & yield",
  "order": 1,
  "reading_content": "\n<h3>Generators in Python</h3>\n<p>Generators are functions that can pause and resume their execution, yielding values one at a time. They're memory-efficient for handling large datasets or infinite sequences.</p>\n\n<h4>Basic Generator with yield:</h4>\n<pre><code># Regular function (returns once)\ndef regular_function():\n    return [1, 2, 3, 4, 5]\n\nresult = regular_function()\nprint(result)  # [1, 2, 3, 4, 5] - entire list in memory\n\n# Generator function (yields multiple times)\ndef number_generator():\n    print(\"Starting generator\")\n    yield 1\n    print(\"After yield 1\")\n    yield 2\n    print(\"After yield 2\")\n    yield 3\n    print(\"After yield 3\")\n\n# Create generator object\ngen = number_generator()\nprint(type(gen))  # <class 'generator'>\n\n# Get values one at a time\nprint(next(gen))  # Starting generator → 1\nprint(next(gen))  # After yield 1 → 2\nprint(next(gen))  # After yield 2 → 3\n# print(next(gen))  # After yield 3 → StopIteration error\n</code></pre>\n\n<h4>Iterating Over Generators:</h4>\n<pre><code>def count_up_to(n):\n    \"\"\"Generate numbers from 1 to n.\"\"\"\n    count = 1\n    while count <= n:\n        yield count\n        count += 1\n\n# Use in for loop (most common)\nfor num in count_up_to(5):\n    print(num)  # 1, 2, 3, 4, 5\n\n# Convert to list (loads all into memory)\nnumbers = list(count_up_to(5))\nprint(numbers)  # [1, 2, 3, 4, 5]\n\n# Use in comprehension\nsquares = [x**2 for x in count_up_to(5)]\nprint(squares)  # [1, 4, 9, 16, 25]\n</code></pre>\n\n<h4>Memory Efficiency Example:</h4>\n<pre><code># Regular function - stores ALL in memory\ndef squares_list(n):\n    \"\"\"Return list of squares (memory-heavy).\"\"\"\n    result = []\n    for i in range(n):\n        result.append(i ** 2)\n    return result\n\n# Generator - one value at a time\ndef squares_generator(n):\n    \"\"\"Generate squares one at a time (memory-efficient).\"\"\"\n    for i in range(n):\n        yield i ** 2\n\n# For 1 million numbers:\nimport sys\n\nlist_squares = squares_list(1000)\ngen_squares = squares_generator(1000)\n\nprint(f\"List size: {sys.getsizeof(list_squares)} bytes\")  # ~8700 bytes\nprint(f\"Generator size: {sys.getsizeof(gen_squares)} bytes\")  # ~120 bytes!\n\n# Generator uses constant memory regardless of size!\n</code></pre>\n\n<h4>Generator Expressions (Generator Comprehensions):</h4>\n<pre><code># List comprehension (creates entire list)\nlist_comp = [x**2 for x in range(10)]\nprint(type(list_comp))  # <class 'list'>\nprint(list_comp)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n# Generator expression (creates generator)\ngen_exp = (x**2 for x in range(10))  # Parentheses instead of brackets!\nprint(type(gen_exp))  # <class 'generator'>\nprint(gen_exp)  # <generator object>\n\n# Iterate to get values\nfor num in gen_exp:\n    print(num, end=' ')  # 0 1 4 9 16 25 36 49 64 81\n\n# Use in functions that accept iterables\nnumbers = (x for x in range(1, 6))\nprint(sum(numbers))  # 15 (efficient!)\n\n# Can only iterate once!\nnumbers = (x for x in range(1, 6))\nprint(list(numbers))  # [1, 2, 3, 4, 5]\nprint(list(numbers))  # [] - exhausted!\n</code></pre>\n\n<h4>Practical Example - Reading Large Files:</h4>\n<pre><code>def read_large_file(filename):\n    \"\"\"Read file line by line (memory-efficient).\"\"\"\n    with open(filename) as file:\n        for line in file:\n            yield line.strip()\n\n# Process huge file without loading all into memory\n# for line in read_large_file('huge_log.txt'):\n#     if 'ERROR' in line:\n#         print(line)\n\n# Bad alternative (loads entire file):\n# with open('huge_log.txt') as f:\n#     lines = f.readlines()  # All in memory!\n#     for line in lines:\n#         if 'ERROR' in line:\n#             print(line)\n</code></pre>\n\n<h4>Practical Example - Fibonacci Sequence:</h4>\n<pre><code>def fibonacci(n):\n    \"\"\"Generate first n Fibonacci numbers.\"\"\"\n    a, b = 0, 1\n    count = 0\n    while count < n:\n        yield a\n        a, b = b, a + b\n        count += 1\n\n# Generate Fibonacci numbers\nfor num in fibonacci(10):\n    print(num, end=' ')  # 0 1 1 2 3 5 8 13 21 34\n\n# Infinite Fibonacci generator\ndef fibonacci_infinite():\n    \"\"\"Generate Fibonacci numbers forever.\"\"\"\n    a, b = 0, 1\n    while True:  # Infinite loop!\n        yield a\n        a, b = b, a + b\n\n# Use with break or limit\nfib = fibonacci_infinite()\nfor _ in range(15):\n    print(next(fib), end=' ')  # First 15 Fibonacci numbers\n</code></pre>\n\n<h4>Generator with State:</h4>\n<pre><code>def running_average():\n    \"\"\"Calculate running average of numbers.\"\"\"\n    total = 0\n    count = 0\n    while True:\n        value = yield\n        if value is None:\n            break\n        total += value\n        count += 1\n        average = total / count\n        print(f\"Current average: {average:.2f}\")\n\navg = running_average()\nnext(avg)  # Prime the generator\navg.send(10)  # Current average: 10.00\navg.send(20)  # Current average: 15.00\navg.send(30)  # Current average: 20.00\navg.send(None)  # Stop\n</code></pre>\n\n<h4>Chaining Generators:</h4>\n<pre><code>def numbers(n):\n    \"\"\"Generate numbers 1 to n.\"\"\"\n    for i in range(1, n + 1):\n        yield i\n\ndef squares(iterable):\n    \"\"\"Square each number from iterable.\"\"\"\n    for num in iterable:\n        yield num ** 2\n\ndef even_only(iterable):\n    \"\"\"Filter only even numbers.\"\"\"\n    for num in iterable:\n        if num % 2 == 0:\n            yield num\n\n# Chain generators together\nresult = even_only(squares(numbers(10)))\nfor num in result:\n    print(num, end=' ')  # 4 16 36 64 100\n\n# Each generator processes one item at a time!\n# Memory-efficient pipeline\n</code></pre>\n\n<h4>Practical Example - Data Processing Pipeline:</h4>\n<pre><code>def read_csv_rows(filename):\n    \"\"\"Read CSV file line by line.\"\"\"\n    with open(filename) as file:\n        next(file)  # Skip header\n        for line in file:\n            yield line.strip().split(',')\n\ndef filter_by_age(rows, min_age):\n    \"\"\"Filter rows where age >= min_age.\"\"\"\n    for row in rows:\n        name, age, city = row\n        if int(age) >= min_age:\n            yield row\n\ndef format_output(rows):\n    \"\"\"Format rows for display.\"\"\"\n    for row in rows:\n        name, age, city = row\n        yield f\"{name} ({age}) from {city}\"\n\n# Process large CSV without loading all into memory\n# rows = read_csv_rows('users.csv')\n# filtered = filter_by_age(rows, 18)\n# formatted = format_output(filtered)\n# \n# for line in formatted:\n#     print(line)\n</code></pre>\n\n<h4>Generator vs List Performance:</h4>\n<pre><code>import time\n\n# List approach (create entire list)\nstart = time.time()\nlist_data = [x**2 for x in range(1000000)]\nsum_list = sum(list_data)\nlist_time = time.time() - start\nprint(f\"List: {list_time:.4f} seconds\")\n\n# Generator approach (one at a time)\nstart = time.time()\ngen_data = (x**2 for x in range(1000000))\nsum_gen = sum(gen_data)\ngen_time = time.time() - start\nprint(f\"Generator: {gen_time:.4f} seconds\")\n\n# Generator is faster AND uses less memory!\n</code></pre>\n\n<h4>When to Use Generators:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Use Case</th>\n        <th>Why Generator?</th>\n    </tr>\n    <tr>\n        <td><strong>Large datasets</strong></td>\n        <td>Process line-by-line without loading all</td>\n    </tr>\n    <tr>\n        <td><strong>Infinite sequences</strong></td>\n        <td>Generate values forever (Fibonacci, counters)</td>\n    </tr>\n    <tr>\n        <td><strong>Pipeline processing</strong></td>\n        <td>Chain operations without intermediate storage</td>\n    </tr>\n    <tr>\n        <td><strong>Memory constraints</strong></td>\n        <td>Constant memory usage</td>\n    </tr>\n    <tr>\n        <td><strong>Lazy evaluation</strong></td>\n        <td>Only compute when needed</td>\n    </tr>\n</table>\n\n<h4>Generator Methods:</h4>\n<pre><code>def my_generator():\n    value = yield 1\n    print(f\"Received: {value}\")\n    value = yield 2\n    print(f\"Received: {value}\")\n\ngen = my_generator()\n\n# next() - Get next value\nprint(next(gen))  # 1\n\n# send() - Send value to generator\nprint(gen.send(\"hello\"))  # Received: hello → 2\n\n# close() - Stop generator\ngen.close()\n\n# throw() - Raise exception in generator\n# gen.throw(ValueError, \"Error!\")\n</code></pre>\n\n<h4>yield from (Delegating Generator):</h4>\n<pre><code># Without yield from\ndef flatten_without(nested_list):\n    for sublist in nested_list:\n        for item in sublist:\n            yield item\n\n# With yield from (cleaner)\ndef flatten_with(nested_list):\n    for sublist in nested_list:\n        yield from sublist  # Delegate to sublist's iterator\n\nnested = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\nprint(list(flatten_with(nested)))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# yield from is shorthand for yielding from another iterable\ndef count_up_to(n):\n    yield from range(1, n + 1)\n\nprint(list(count_up_to(5)))  # [1, 2, 3, 4, 5]\n</code></pre>\n        ",
  "starter_code": "# TODO: Create a generator function that generates prime numbers:\n# Function: prime_generator(limit)\n# - Yields prime numbers up to limit\n# - A prime number is only divisible by 1 and itself\n# - Use yield to generate one prime at a time\n# \n# Test:\n# for prime in prime_generator(20):\n#     print(prime, end=' ')\n# Output: 2 3 5 7 11 13 17 19\n\n",
  "solution_code": "def prime_generator(limit):\n    \"\"\"Generate prime numbers up to limit.\"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    for num in range(2, limit + 1):\n        if is_prime(num):\n            yield num\n\nfor prime in prime_generator(20):\n    print(prime, end=' ')  # 2 3 5 7 11 13 17 19",
  "learning_objectives": [
    "Understand generators and yield keyword",
    "Create memory-efficient iterators",
    "Use generator expressions",
    "Build data processing pipelines with generators"
  ],
  "key_concepts": [
    "Generators",
    "yield Keyword",
    "Generator Functions",
    "Generator Expressions",
    "Memory Efficiency",
    "Lazy Evaluation",
    "next() Function",
    "yield from"
  ],
  "test_cases": [
    {
      "name": "Test: Prime number generator",
      "input": "",
      "expected_output": "2 3 5 7 11 13 17 19"
    }
  ],
  "hints": [
    "Generator function: def func(): ... yield value",
    "Check if prime: for i in range(2, int(n**0.5)+1): if n%i==0: return False",
    "Yield primes: if is_prime(num): yield num",
    "Iterate: for num in range(2, limit+1): ...",
    "Use helper function is_prime(n) to check primality"
  ],
  "visual_content": {
    "diagram": {
      "type": "generator_concept",
      "title": "Generators vs Regular Functions",
      "comparison": {
        "regular_function": {
          "code": "def func():\\n    return [1, 2, 3]",
          "behavior": "Returns once, entire list in memory",
          "memory": "High (stores all values)"
        },
        "generator_function": {
          "code": "def func():\\n    yield 1\\n    yield 2\\n    yield 3",
          "behavior": "Yields multiple times, pauses between",
          "memory": "Low (one value at a time)"
        }
      },
      "execution_flow": "1. Call generator → creates generator object\\n2. next(gen) → executes until first yield\\n3. next(gen) → resumes, executes until next yield\\n4. Loop continues until StopIteration",
      "generator_expression": {
        "list": "[x**2 for x in range(10)]  # List (all in memory)",
        "generator": "(x**2 for x in range(10))  # Generator (lazy)"
      }
    }
  }
}