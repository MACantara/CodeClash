{
  "module_id": 6,
  "title": "Exception Handling (try-except)",
  "order": 4,
  "reading_content": "\n<h3>Handling Errors with try-except</h3>\n<p>Exceptions are errors that occur during program execution. Python uses try-except blocks to handle these errors gracefully instead of crashing.</p>\n\n<h4>Basic try-except:</h4>\n<pre><code># Without exception handling (program crashes)\nnumber = int(input(\"Enter a number: \"))  # If user enters \"abc\", ValueError!\nprint(f\"You entered: {number}\")\n\n# With exception handling (program continues)\ntry:\n    number = int(input(\"Enter a number: \"))\n    print(f\"You entered: {number}\")\nexcept ValueError:\n    print(\"That's not a valid number!\")\n\n# Program continues normally\nprint(\"Program finished\")\n</code></pre>\n\n<h4>Catching Specific Exceptions:</h4>\n<pre><code>try:\n    numbers = [1, 2, 3]\n    print(numbers[10])  # IndexError\nexcept IndexError:\n    print(\"Index out of range!\")\n\ntry:\n    result = 10 / 0  # ZeroDivisionError\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n\ntry:\n    dictionary = {'name': 'Alice'}\n    print(dictionary['age'])  # KeyError\nexcept KeyError:\n    print(\"Key not found!\")\n\ntry:\n    file = open('nonexistent.txt')  # FileNotFoundError\nexcept FileNotFoundError:\n    print(\"File not found!\")\n</code></pre>\n\n<h4>Multiple except Clauses:</h4>\n<pre><code>def divide_numbers(a, b):\n    try:\n        result = a / b\n        return result\n    except ZeroDivisionError:\n        return \"Error: Cannot divide by zero\"\n    except TypeError:\n        return \"Error: Please provide numbers\"\n\nprint(divide_numbers(10, 2))     # 5.0\nprint(divide_numbers(10, 0))     # Error: Cannot divide by zero\nprint(divide_numbers(10, \"a\"))   # Error: Please provide numbers\n</code></pre>\n\n<h4>Catching Multiple Exceptions:</h4>\n<pre><code># Catch multiple exceptions with same handler\ntry:\n    value = int(input(\"Enter a number: \"))\n    result = 100 / value\n    print(result)\nexcept (ValueError, ZeroDivisionError):\n    print(\"Invalid input or division by zero!\")\n\n# Better: Handle separately for specific messages\ntry:\n    value = int(input(\"Enter a number: \"))\n    result = 100 / value\n    print(result)\nexcept ValueError:\n    print(\"Please enter a valid number!\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n</code></pre>\n\n<h4>Getting Exception Details:</h4>\n<pre><code># Capture exception object\ntry:\n    numbers = [1, 2, 3]\n    print(numbers[10])\nexcept IndexError as e:\n    print(f\"Error occurred: {e}\")  # Error occurred: list index out of range\n    print(f\"Exception type: {type(e).__name__}\")  # Exception type: IndexError\n\n# Useful for logging\nimport logging\n\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    logging.error(f\"Division error: {e}\")\n    print(\"An error was logged\")\n</code></pre>\n\n<h4>else Clause (Runs if No Exception):</h4>\n<pre><code>try:\n    number = int(input(\"Enter a number: \"))\nexcept ValueError:\n    print(\"Invalid number!\")\nelse:\n    # Runs ONLY if no exception occurred\n    print(f\"Successfully converted: {number}\")\n    print(f\"Double: {number * 2}\")\n\n# Example with file handling\ntry:\n    file = open('data.txt', 'r')\nexcept FileNotFoundError:\n    print(\"File not found!\")\nelse:\n    # File opened successfully\n    content = file.read()\n    print(content)\n    file.close()\n</code></pre>\n\n<h4>finally Clause (Always Runs):</h4>\n<pre><code># finally runs whether exception occurred or not\ntry:\n    file = open('data.txt', 'r')\n    content = file.read()\n    print(content)\nexcept FileNotFoundError:\n    print(\"File not found!\")\nfinally:\n    # Always close file, even if error occurred\n    try:\n        file.close()\n        print(\"File closed\")\n    except:\n        pass  # File wasn't opened\n\n# Common pattern: Resource cleanup\ndef process_file(filename):\n    file = None\n    try:\n        file = open(filename, 'r')\n        data = file.read()\n        # Process data...\n        return data\n    except FileNotFoundError:\n        print(f\"Error: {filename} not found\")\n        return None\n    finally:\n        # Cleanup: Always close file\n        if file:\n            file.close()\n            print(\"File closed in finally\")\n</code></pre>\n\n<h4>Complete try-except-else-finally:</h4>\n<pre><code>def safe_divide(a, b):\n    \"\"\"Divide a by b with full exception handling.\"\"\"\n    try:\n        result = a / b\n    except TypeError:\n        print(\"Error: Both arguments must be numbers\")\n        return None\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero\")\n        return None\n    else:\n        # Runs if no exception\n        print(f\"Division successful: {a} / {b}\")\n        return result\n    finally:\n        # Always runs (cleanup code)\n        print(\"Division operation completed\")\n\nprint(safe_divide(10, 2))\nprint()\nprint(safe_divide(10, 0))\nprint()\nprint(safe_divide(10, \"a\"))\n</code></pre>\n\n<h4>Common Python Exceptions:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Exception</th>\n        <th>When It Occurs</th>\n        <th>Example</th>\n    </tr>\n    <tr>\n        <td><strong>ValueError</strong></td>\n        <td>Invalid value for operation</td>\n        <td>int(\"abc\")</td>\n    </tr>\n    <tr>\n        <td><strong>TypeError</strong></td>\n        <td>Wrong type for operation</td>\n        <td>\"text\" + 5</td>\n    </tr>\n    <tr>\n        <td><strong>IndexError</strong></td>\n        <td>List index out of range</td>\n        <td>[1, 2][10]</td>\n    </tr>\n    <tr>\n        <td><strong>KeyError</strong></td>\n        <td>Dictionary key not found</td>\n        <td>{'a': 1}['b']</td>\n    </tr>\n    <tr>\n        <td><strong>ZeroDivisionError</strong></td>\n        <td>Division by zero</td>\n        <td>10 / 0</td>\n    </tr>\n    <tr>\n        <td><strong>FileNotFoundError</strong></td>\n        <td>File doesn't exist</td>\n        <td>open('missing.txt')</td>\n    </tr>\n    <tr>\n        <td><strong>AttributeError</strong></td>\n        <td>Attribute doesn't exist</td>\n        <td>\"text\".nonexistent()</td>\n    </tr>\n    <tr>\n        <td><strong>ImportError</strong></td>\n        <td>Module can't be imported</td>\n        <td>import nonexistent</td>\n    </tr>\n</table>\n\n<h4>Practical Example - User Input Validation:</h4>\n<pre><code>def get_positive_integer(prompt):\n    \"\"\"Get a positive integer from user with validation.\"\"\"\n    while True:\n        try:\n            value = int(input(prompt))\n            if value <= 0:\n                print(\"Please enter a positive number!\")\n                continue\n            return value\n        except ValueError:\n            print(\"Invalid input! Please enter a number.\")\n\ndef get_age():\n    \"\"\"Get valid age from user.\"\"\"\n    while True:\n        try:\n            age = int(input(\"Enter your age: \"))\n            if age < 0 or age > 120:\n                print(\"Age must be between 0 and 120\")\n                continue\n            return age\n        except ValueError:\n            print(\"Please enter a valid number!\")\n\n# Usage\nage = get_age()\nprint(f\"Your age is: {age}\")\n</code></pre>\n\n<h4>Practical Example - Safe Dictionary Access:</h4>\n<pre><code>def get_user_info(user_data, key):\n    \"\"\"Safely get user information.\"\"\"\n    try:\n        return user_data[key]\n    except KeyError:\n        return f\"Key '{key}' not found\"\n    except TypeError:\n        return \"Error: Invalid data structure\"\n\nuser = {'name': 'Alice', 'age': 25}\n\nprint(get_user_info(user, 'name'))     # Alice\nprint(get_user_info(user, 'email'))    # Key 'email' not found\nprint(get_user_info(None, 'name'))     # Error: Invalid data structure\n\n# Using dict.get() as alternative (returns None if key missing)\nprint(user.get('email'))               # None\nprint(user.get('email', 'Not found'))  # Not found (default value)\n</code></pre>\n\n<h4>Practical Example - File Operations:</h4>\n<pre><code>def read_file_safely(filename):\n    \"\"\"Read file with proper exception handling.\"\"\"\n    try:\n        with open(filename, 'r') as file:\n            content = file.read()\n            return content\n    except FileNotFoundError:\n        print(f\"Error: File '{filename}' not found\")\n        return None\n    except PermissionError:\n        print(f\"Error: No permission to read '{filename}'\")\n        return None\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n\ndef write_file_safely(filename, content):\n    \"\"\"Write to file with proper exception handling.\"\"\"\n    try:\n        with open(filename, 'w') as file:\n            file.write(content)\n            print(f\"Successfully wrote to {filename}\")\n            return True\n    except PermissionError:\n        print(f\"Error: No permission to write to '{filename}'\")\n        return False\n    except Exception as e:\n        print(f\"Error writing file: {e}\")\n        return False\n\n# Usage\ncontent = read_file_safely('data.txt')\nif content:\n    print(content)\n\nwrite_file_safely('output.txt', 'Hello, World!')\n</code></pre>\n\n<h4>When to Use Exception Handling:</h4>\n<pre><code># ✅ Good: Handle expected errors\ntry:\n    age = int(input(\"Age: \"))  # User might enter text\nexcept ValueError:\n    print(\"Invalid age\")\n\n# ✅ Good: Handle file operations\ntry:\n    file = open('data.txt')  # File might not exist\nexcept FileNotFoundError:\n    print(\"File not found\")\n\n# ❌ Bad: Catching too broadly\ntry:\n    # Complex code\n    result = complex_calculation()\nexcept:  # Catches EVERYTHING, even bugs!\n    print(\"Something went wrong\")\n\n# ✅ Better: Catch specific exceptions\ntry:\n    result = complex_calculation()\nexcept ValueError:\n    print(\"Invalid value\")\nexcept ZeroDivisionError:\n    print(\"Division by zero\")\n\n# ✅ Good: Use finally for cleanup\nfile = None\ntry:\n    file = open('data.txt')\n    # Process file\nfinally:\n    if file:\n        file.close()  # Always close\n</code></pre>\n\n<h4>LBYL vs EAFP:</h4>\n<pre><code># LBYL: Look Before You Leap (check first)\nif 'key' in dictionary:\n    value = dictionary['key']\nelse:\n    value = None\n\n# EAFP: Easier to Ask for Forgiveness than Permission (try it)\ntry:\n    value = dictionary['key']\nexcept KeyError:\n    value = None\n\n# EAFP is more Pythonic!\n# It's faster when exception is rare\n# It handles race conditions better\n</code></pre>\n        ",
  "starter_code": "# TODO: Create a calculator function with exception handling:\n# Function: safe_calculator(num1, num2, operation)\n# Operations: '+', '-', '*', '/'\n# \n# Handle these exceptions:\n# - TypeError: If num1 or num2 are not numbers\n# - ZeroDivisionError: If dividing by zero\n# - ValueError: If operation is not one of +, -, *, /\n# \n# Return the result if successful, or appropriate error message\n# \n# Test:\n# print(safe_calculator(10, 2, '+'))    # 12\n# print(safe_calculator(10, 0, '/'))    # Error: Division by zero\n# print(safe_calculator(10, 'a', '+'))  # Error: Arguments must be numbers\n# print(safe_calculator(10, 2, '%'))    # Error: Invalid operation\n\n",
  "solution_code": "def safe_calculator(num1, num2, operation):\n    try:\n        # Check if inputs are numbers\n        if not isinstance(num1, (int, float)) or not isinstance(num2, (int, float)):\n            raise TypeError\n        \n        # Perform operation\n        if operation == '+':\n            return num1 + num2\n        elif operation == '-':\n            return num1 - num2\n        elif operation == '*':\n            return num1 * num2\n        elif operation == '/':\n            return num1 / num2\n        else:\n            raise ValueError\n    \n    except TypeError:\n        return \"Error: Arguments must be numbers\"\n    except ZeroDivisionError:\n        return \"Error: Division by zero\"\n    except ValueError:\n        return \"Error: Invalid operation\"\n\nprint(safe_calculator(10, 2, '+'))    # 12\nprint(safe_calculator(10, 0, '/'))    # Error: Division by zero\nprint(safe_calculator(10, 'a', '+'))  # Error: Arguments must be numbers\nprint(safe_calculator(10, 2, '%'))    # Error: Invalid operation",
  "learning_objectives": [
    "Handle exceptions with try-except blocks",
    "Catch specific exceptions appropriately",
    "Use else and finally clauses effectively",
    "Understand common Python exception types"
  ],
  "key_concepts": [
    "Exceptions",
    "try-except",
    "Multiple except Clauses",
    "except Exception as e",
    "else Clause",
    "finally Clause",
    "Common Exception Types",
    "EAFP vs LBYL"
  ],
  "test_cases": [
    {
      "name": "Test: Safe calculator",
      "input": "",
      "expected_output": "12\nError: Division by zero\nError: Arguments must be numbers\nError: Invalid operation"
    }
  ],
  "hints": [
    "try-except structure: try: ... except ExceptionType: ...",
    "Check type: isinstance(num1, (int, float))",
    "Raise exception: raise TypeError or raise ValueError",
    "Catch ZeroDivisionError for division by zero",
    "Multiple except clauses for different error types"
  ],
  "visual_content": {
    "diagram": {
      "type": "exception_flow",
      "title": "Exception Handling Flow",
      "structure": "try:\\n    # Code that might fail\\n    risky_operation()\\nexcept SpecificException:\\n    # Handle specific error\\n    print('Specific error')\\nexcept AnotherException:\\n    # Handle another error\\n    print('Another error')\\nelse:\\n    # Runs if NO exception\\n    print('Success')\\nfinally:\\n    # ALWAYS runs (cleanup)\\n    print('Cleanup')",
      "execution_paths": [
        {"scenario": "No error", "flow": "try → else → finally"},
        {"scenario": "Exception caught", "flow": "try → except → finally"},
        {"scenario": "Exception not caught", "flow": "try → finally → crash"}
      ],
      "common_exceptions": {
        "ValueError": "int('abc')",
        "TypeError": "'text' + 5",
        "IndexError": "[1,2][10]",
        "KeyError": "dict['missing']",
        "ZeroDivisionError": "10 / 0",
        "FileNotFoundError": "open('missing.txt')"
      }
    }
  }
}