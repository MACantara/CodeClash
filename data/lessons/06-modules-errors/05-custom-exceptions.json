{
  "module_id": 6,
  "title": "Custom Exceptions & Raising Errors",
  "order": 5,
  "reading_content": "\n<h3>Creating and Raising Custom Exceptions</h3>\n<p>Python allows you to create custom exception classes and raise exceptions when certain conditions aren't met. This makes your code more expressive and easier to debug.</p>\n\n<h4>Raising Built-in Exceptions:</h4>\n<pre><code># Raise an exception manually\ndef validate_age(age):\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    if age > 120:\n        raise ValueError(\"Age seems unrealistic\")\n    return age\n\ntry:\n    validate_age(-5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Error: Age cannot be negative\n\n# Raise with no message\ndef divide(a, b):\n    if b == 0:\n        raise ZeroDivisionError  # No custom message\n    return a / b\n\n# Raise TypeError\ndef add_numbers(a, b):\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numbers\")\n    return a + b\n</code></pre>\n\n<h4>Creating Custom Exception Classes:</h4>\n<pre><code># Basic custom exception (inherits from Exception)\nclass InvalidEmailError(Exception):\n    \"\"\"Raised when email format is invalid.\"\"\"\n    pass\n\ndef validate_email(email):\n    if '@' not in email:\n        raise InvalidEmailError(\"Email must contain @ symbol\")\n    if not email.endswith('.com') and not email.endswith('.org'):\n        raise InvalidEmailError(\"Email must end with .com or .org\")\n    return email\n\ntry:\n    validate_email(\"invalid-email\")\nexcept InvalidEmailError as e:\n    print(f\"Error: {e}\")  # Error: Email must contain @ symbol\n</code></pre>\n\n<h4>Custom Exceptions with Additional Data:</h4>\n<pre><code>class InsufficientFundsError(Exception):\n    \"\"\"Raised when account has insufficient funds.\"\"\"\n    \n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        self.shortage = amount - balance\n        message = f\"Insufficient funds: need ${amount}, but only have ${balance}\"\n        super().__init__(message)\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n    \n    def withdraw(self, amount):\n        if amount > self.balance:\n            raise InsufficientFundsError(self.balance, amount)\n        self.balance -= amount\n        return self.balance\n\n# Usage\naccount = BankAccount(100)\n\ntry:\n    account.withdraw(150)\nexcept InsufficientFundsError as e:\n    print(e)  # Insufficient funds: need $150, but only have $100\n    print(f\"Short by: ${e.shortage}\")  # Short by: $50\n</code></pre>\n\n<h4>Exception Hierarchy:</h4>\n<pre><code># Create exception hierarchy for better organization\nclass ValidationError(Exception):\n    \"\"\"Base class for validation errors.\"\"\"\n    pass\n\nclass EmailValidationError(ValidationError):\n    \"\"\"Raised for email validation issues.\"\"\"\n    pass\n\nclass PhoneValidationError(ValidationError):\n    \"\"\"Raised for phone validation issues.\"\"\"\n    pass\n\nclass PasswordValidationError(ValidationError):\n    \"\"\"Raised for password validation issues.\"\"\"\n    pass\n\ndef validate_user_data(email, phone, password):\n    if '@' not in email:\n        raise EmailValidationError(\"Invalid email format\")\n    \n    if len(phone) < 10:\n        raise PhoneValidationError(\"Phone must be at least 10 digits\")\n    \n    if len(password) < 8:\n        raise PasswordValidationError(\"Password must be at least 8 characters\")\n\n# Catch all validation errors\ntry:\n    validate_user_data(\"bademail\", \"123\", \"weak\")\nexcept ValidationError as e:\n    # Catches any validation error\n    print(f\"Validation failed: {e}\")\n\n# Or catch specific errors\ntry:\n    validate_user_data(\"user@email.com\", \"123\", \"weak\")\nexcept EmailValidationError as e:\n    print(f\"Email error: {e}\")\nexcept PhoneValidationError as e:\n    print(f\"Phone error: {e}\")\nexcept PasswordValidationError as e:\n    print(f\"Password error: {e}\")  # This one triggers\n</code></pre>\n\n<h4>Re-raising Exceptions:</h4>\n<pre><code># Re-raise after logging or partial handling\ndef process_data(data):\n    try:\n        result = int(data)\n        return result\n    except ValueError as e:\n        print(f\"Logging error: {e}\")\n        raise  # Re-raise the same exception\n\ntry:\n    process_data(\"abc\")\nexcept ValueError:\n    print(\"Caught re-raised exception\")\n\n# Re-raise with different exception\ndef load_config(filename):\n    try:\n        with open(filename) as f:\n            return f.read()\n    except FileNotFoundError:\n        # Convert to more specific error\n        raise ConfigurationError(f\"Config file '{filename}' not found\")\n\nclass ConfigurationError(Exception):\n    pass\n</code></pre>\n\n<h4>Exception Chaining (from):</h4>\n<pre><code># Chain exceptions to preserve context\nclass DataProcessingError(Exception):\n    pass\n\ndef process_file(filename):\n    try:\n        with open(filename) as f:\n            data = f.read()\n            return int(data)  # Might raise ValueError\n    except FileNotFoundError as e:\n        # Chain: new exception caused by original\n        raise DataProcessingError(\"Failed to process file\") from e\n    except ValueError as e:\n        raise DataProcessingError(\"Invalid data format\") from e\n\ntry:\n    process_file(\"data.txt\")\nexcept DataProcessingError as e:\n    print(f\"Error: {e}\")\n    print(f\"Caused by: {e.__cause__}\")  # Original exception\n</code></pre>\n\n<h4>Practical Example - User Registration System:</h4>\n<pre><code>class RegistrationError(Exception):\n    \"\"\"Base exception for registration errors.\"\"\"\n    pass\n\nclass UsernameError(RegistrationError):\n    pass\n\nclass EmailError(RegistrationError):\n    pass\n\nclass PasswordError(RegistrationError):\n    pass\n\nclass User:\n    existing_usernames = set()\n    existing_emails = set()\n    \n    def __init__(self, username, email, password):\n        # Validate username\n        if len(username) < 3:\n            raise UsernameError(\"Username must be at least 3 characters\")\n        if username in User.existing_usernames:\n            raise UsernameError(f\"Username '{username}' already taken\")\n        \n        # Validate email\n        if '@' not in email or '.' not in email:\n            raise EmailError(\"Invalid email format\")\n        if email in User.existing_emails:\n            raise EmailError(f\"Email '{email}' already registered\")\n        \n        # Validate password\n        if len(password) < 8:\n            raise PasswordError(\"Password must be at least 8 characters\")\n        if not any(c.isupper() for c in password):\n            raise PasswordError(\"Password must contain uppercase letter\")\n        if not any(c.isdigit() for c in password):\n            raise PasswordError(\"Password must contain a digit\")\n        \n        # Save user\n        self.username = username\n        self.email = email\n        self._password = password\n        User.existing_usernames.add(username)\n        User.existing_emails.add(email)\n\ndef register_user(username, email, password):\n    \"\"\"Register a new user with proper error handling.\"\"\"\n    try:\n        user = User(username, email, password)\n        return f\"User '{username}' registered successfully!\"\n    except UsernameError as e:\n        return f\"Username error: {e}\"\n    except EmailError as e:\n        return f\"Email error: {e}\"\n    except PasswordError as e:\n        return f\"Password error: {e}\"\n    except RegistrationError as e:\n        return f\"Registration error: {e}\"\n\n# Test registration\nprint(register_user(\"alice\", \"alice@email.com\", \"Password123\"))\nprint(register_user(\"bob\", \"bob@email.com\", \"weak\"))  # Password error\nprint(register_user(\"alice\", \"alice2@email.com\", \"Password456\"))  # Username taken\nprint(register_user(\"charlie\", \"alice@email.com\", \"Password789\"))  # Email taken\n</code></pre>\n\n<h4>Practical Example - API Request Handler:</h4>\n<pre><code>class APIError(Exception):\n    \"\"\"Base class for API errors.\"\"\"\n    pass\n\nclass AuthenticationError(APIError):\n    \"\"\"Raised when authentication fails.\"\"\"\n    pass\n\nclass RateLimitError(APIError):\n    \"\"\"Raised when rate limit exceeded.\"\"\"\n    def __init__(self, retry_after):\n        self.retry_after = retry_after\n        super().__init__(f\"Rate limit exceeded. Retry after {retry_after} seconds\")\n\nclass ResourceNotFoundError(APIError):\n    \"\"\"Raised when resource doesn't exist.\"\"\"\n    pass\n\nclass API:\n    def __init__(self, api_key):\n        self.api_key = api_key\n        self.request_count = 0\n        self.max_requests = 100\n    \n    def make_request(self, endpoint):\n        # Check authentication\n        if not self.api_key:\n            raise AuthenticationError(\"API key required\")\n        \n        # Check rate limit\n        if self.request_count >= self.max_requests:\n            raise RateLimitError(retry_after=60)\n        \n        # Simulate request\n        self.request_count += 1\n        \n        # Check if resource exists\n        valid_endpoints = ['users', 'posts', 'comments']\n        if endpoint not in valid_endpoints:\n            raise ResourceNotFoundError(f\"Endpoint '{endpoint}' not found\")\n        \n        return f\"Success: Data from {endpoint}\"\n\n# Usage\napi = API(\"my-api-key\")\n\ntry:\n    result = api.make_request('users')\n    print(result)\nexcept AuthenticationError as e:\n    print(f\"Auth error: {e}\")\nexcept RateLimitError as e:\n    print(f\"Rate limit: {e}\")\n    print(f\"Wait {e.retry_after} seconds\")\nexcept ResourceNotFoundError as e:\n    print(f\"Not found: {e}\")\nexcept APIError as e:\n    print(f\"API error: {e}\")\n</code></pre>\n\n<h4>Best Practices for Custom Exceptions:</h4>\n<table border='1' style='border-collapse: collapse; padding: 8px;'>\n    <tr>\n        <th>Practice</th>\n        <th>Why</th>\n    </tr>\n    <tr>\n        <td><strong>Inherit from Exception</strong></td>\n        <td>Standard base class for all exceptions</td>\n    </tr>\n    <tr>\n        <td><strong>Descriptive names</strong></td>\n        <td>End with 'Error' (ValueError, CustomError)</td>\n    </tr>\n    <tr>\n        <td><strong>Add docstrings</strong></td>\n        <td>Explain when exception is raised</td>\n    </tr>\n    <tr>\n        <td><strong>Create hierarchy</strong></td>\n        <td>Group related exceptions under base class</td>\n    </tr>\n    <tr>\n        <td><strong>Store useful data</strong></td>\n        <td>Help caller handle exception properly</td>\n    </tr>\n    <tr>\n        <td><strong>Raise early</strong></td>\n        <td>Validate inputs at function start</td>\n    </tr>\n</table>\n\n<h4>When to Create Custom Exceptions:</h4>\n<pre><code># ✅ Good: Domain-specific errors\nclass InsufficientFundsError(Exception):  # Banking domain\n    pass\n\nclass InvalidMoveError(Exception):  # Chess game\n    pass\n\n# ✅ Good: Grouping related errors\nclass ValidationError(Exception):\n    pass\n\nclass EmailValidationError(ValidationError):\n    pass\n\n# ❌ Bad: Unnecessary custom exception\nclass MyValueError(Exception):  # Just use ValueError!\n    pass\n\n# ✅ Good: Add context to built-in exception\nif value < 0:\n    raise ValueError(\"Age cannot be negative\")  # Clear message\n</code></pre>\n\n<h4>Assertion Errors (for Development):</h4>\n<pre><code># Use assertions for debugging (disabled with python -O)\ndef calculate_average(numbers):\n    assert len(numbers) > 0, \"List cannot be empty\"  # Development check\n    assert all(isinstance(n, (int, float)) for n in numbers), \"All must be numbers\"\n    return sum(numbers) / len(numbers)\n\n# Assertions vs Exceptions:\n# - Assertions: Internal checks, can be disabled\n# - Exceptions: Expected errors, always checked\n\n# ✅ Use assertion for internal checks:\nassert self.balance >= 0, \"Balance should never be negative\"\n\n# ✅ Use exception for expected errors:\nif amount < 0:\n    raise ValueError(\"Amount cannot be negative\")\n</code></pre>\n        ",
  "starter_code": "# TODO: Create a custom exception system for a temperature class:\n# 1. Create custom exception TemperatureError (base class)\n# 2. Create FreezingPointError (inherits from TemperatureError)\n# 3. Create BoilingPointError (inherits from TemperatureError)\n# \n# Create class Temperature:\n# - __init__(celsius) - Raise FreezingPointError if < -273.15 (absolute zero)\n#                     - Raise BoilingPointError if > 1000 (unrealistic)\n# - Store celsius value if valid\n# \n# Test:\n# temp1 = Temperature(25)  # OK\n# temp2 = Temperature(-300)  # Raises FreezingPointError\n# temp3 = Temperature(1500)  # Raises BoilingPointError\n\n",
  "solution_code": "class TemperatureError(Exception):\n    \"\"\"Base exception for temperature errors.\"\"\"\n    pass\n\nclass FreezingPointError(TemperatureError):\n    \"\"\"Raised when temperature is below absolute zero.\"\"\"\n    pass\n\nclass BoilingPointError(TemperatureError):\n    \"\"\"Raised when temperature is unrealistically high.\"\"\"\n    pass\n\nclass Temperature:\n    def __init__(self, celsius):\n        if celsius < -273.15:\n            raise FreezingPointError(f\"Temperature {celsius}°C is below absolute zero (-273.15°C)\")\n        if celsius > 1000:\n            raise BoilingPointError(f\"Temperature {celsius}°C is unrealistically high\")\n        self.celsius = celsius\n    \n    def __str__(self):\n        return f\"{self.celsius}°C\"\n\n# Test\ntry:\n    temp1 = Temperature(25)\n    print(f\"Valid: {temp1}\")\nexcept TemperatureError as e:\n    print(e)\n\ntry:\n    temp2 = Temperature(-300)\nexcept FreezingPointError as e:\n    print(f\"Error: {e}\")\n\ntry:\n    temp3 = Temperature(1500)\nexcept BoilingPointError as e:\n    print(f\"Error: {e}\")",
  "learning_objectives": [
    "Create custom exception classes",
    "Raise exceptions with raise statement",
    "Build exception hierarchies for better organization",
    "Add custom data to exceptions"
  ],
  "key_concepts": [
    "Custom Exceptions",
    "raise Statement",
    "Exception Hierarchy",
    "Exception Chaining (from)",
    "Re-raising Exceptions",
    "class CustomError(Exception)",
    "Best Practices for Exceptions"
  ],
  "test_cases": [
    {
      "name": "Test: Temperature validation",
      "input": "",
      "expected_output": "Valid: 25°C\nError: Temperature -300°C is below absolute zero\nError: Temperature 1500°C is unrealistically high"
    }
  ],
  "hints": [
    "Custom exception: class TemperatureError(Exception): pass",
    "Child exception: class FreezingPointError(TemperatureError): pass",
    "Raise exception: raise FreezingPointError('message')",
    "Check conditions: if celsius < -273.15: raise ...",
    "Try-except: try: Temperature(-300) except FreezingPointError as e: ..."
  ],
  "visual_content": {
    "diagram": {
      "type": "custom_exceptions",
      "title": "Custom Exception Hierarchy",
      "example": {
        "base": "Exception (built-in)\\n    ↓\\n  ValidationError (custom base)\\n    ├── EmailValidationError\\n    ├── PhoneValidationError\\n    └── PasswordValidationError",
        "benefits": "1. Catch all: except ValidationError\\n2. Catch specific: except EmailValidationError\\n3. Clear error types\\n4. Easy to extend"
      },
      "creating": {
        "basic": "class CustomError(Exception):\\n    pass",
        "with_data": "class CustomError(Exception):\\n    def __init__(self, value):\\n        self.value = value\\n        super().__init__(f'Error: {value}')",
        "hierarchy": "class BaseError(Exception):\\n    pass\\n\\nclass SpecificError(BaseError):\\n    pass"
      },
      "raising": {
        "basic": "raise ValueError('message')",
        "custom": "raise CustomError('message')",
        "reraise": "except Exception:\\n    # Log error\\n    raise  # Re-raise same exception",
        "chain": "except FileNotFoundError as e:\\n    raise CustomError('msg') from e"
      }
    }
  }
}